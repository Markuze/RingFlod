\section{Attack setup}
In all our complete attacks except one, we attacked a Linux machine running Ubuntu Server 15.10 (Linux kernel 4.2) with Intel VT-d as the IOMMU and a Broadcom NetXtreme II BCM5709 Gigabit Ethernet card as the network controller when we needed a physical one. In later experiments, we used newer versions of Ubuntu (16.04–17.10) but did not implement a complete attack against these versions. An identical machine that was connected to the victim machine with a FireWire cable simulated the attacker. In our final experiment, we attacked FreeBSD 10.3 running on the same hardware.  Linux kernel supports emulating hard disks for remote computers, which is implemented in the Linux-IO Target (LIO) subsystem. We modified the login function of the SBP-2 disk emulator on the attacking machine to invoke the attack, in addition to its normal work, whenever we wanted to attack using a physical device.To attack a physical machine using an unmodified network card, we used a FireWire device in a similar technique to the one used by Sang et al. [SLND10]: by carefully modifying the victim’s OS, we forced it to believe that the network card and the FireWire device were actually the same device (PCI aliases), and made them use the same IOVA page tables. In this way, we could attack using a programmable interface without having to modify the real attacking device, which, in general, is much harder.
\subsection{Linux FireWire}
We found that the Linux FireWire driver suffers from sub-page granularity vulnerability with a colocality of device data with driver metadata that remains valid regardless of IOTLB eviction policy. into different ORB formats. SBP\-2 (serial bus protocol \#2) was developed to allow the use of SCSI devices over Firewire. While Firewire is an old physical connector that no longer exists in modern computer systems, there are cables that allow seamless conversion between Firewire and Thunderbolt, which enable us to use Firewire in modern setups. In this work, we are concerned only with “LOGIN”, a management ORB that initiates new connections. To connect to a target, the initiator sends a login request, formatted as shown in Figure 2.2. When the target is ready, it fills the buffer that was pointed to by the request with a login response(shown in Figure 2.3) using DMA, and reports to the initiator that it has done so. As we will show in Section 4.1.1, this single DMA write is enough for a malicious device to attack a Linux machine. In other attacks, we used this DMA write as an entry point for the attack, issuing other DMA writes regardless of the original behavior. The protocol defines ORB (Operation Request Block) as the data structure that represents the initiator’s requests [Joh98]. There are many possible messages, classified To establish an SBP-2 connection, the initiator issues a login ORB. To be precise, it sends a login request and the target responses with a login response. In Linux’s SBP-2 driver, management ORBs, and the login ORB in particular, are represented by the sbp2 management orb data structure. This data structure holds the buffers for the request and the response, as well as other fields necessary for the communication. The fields that are relevant for the attack are shown in Figure 4.1. In order to enable the communication, the driver maps the request and response fields in sbp2 management orb for read and write by the device, respectively. As a result, it is entirely visible to the device both for reading and writing. Consequently, the device is able to read and manipulate metadata that controls its behavior. Luckily for us, sbp2 management orb contains a callback function that is called after the target has responded. By overriding this pointer, attackers can run arbitrary code in the kernel context. We note that in the general case, the original callback must be called before/after the attack code, so the device behavior will not break. In this specific case, however, we saw that the original callback creates no actual side effects and could be ignored. Listing 4.2 illustrates the mapping process of sbp2 management orb and the use of a callback. Now, the attacker needs to bring the shellcode into the victim’s memory and point to it using a regular virtual address. When we attacked this driver, we wrote the shellcode in the same already device-writable page. In fact, in the basic attack, the shellcode was small enough to fit into the unused space between the sbp2 management orb structure and the end of the slub object (whose size is always a power of two). In later versions of the payload, we manipulated the memory allocator’s freelist in order to make room for the attack payload. The last field we used in sbp2 management orb is base.t.link. This field is used in lower level transactions of FireWire and is guaranteed to point to itself when the target receives the request (i.e., when we attack). By reading this pointer, the attacker is able to deduce the shellcode’s virtual address and set it into callback to launch the attack. \textcolor{magenta}{The entire attack code is outlined in Listing 4.3. - Appendix (?) } Reading it directly from sbp2 management orb, however, works better and is more robust.
\subsection{FreeBSD UMA}
We use FireWire to target the FreeBSD Universal Memory Allocator(UMA). By attacking the kernel memory allocator rather than the driver of a specific device, we demonstrate that the problem is not unique to buggy drivers. Saving metadata that is related to the memory management within a data page is a common method for memory allocators and we show that this is a dangerous practice [Cor07, ak09]. FreeBSD is somewhat simpler because its memory maps are always both for reading and writing by the device.UMA is the memory allocator that the FreeBSD kernel uses internally for it own memory allocations. In order to not waste more memory than it has to, UMA saves some management metadata in a structure within data pages when possible (e.g., when the size of the objects is small enough); otherwise, it saves all the management metadata off-page. Inspired by the way Argp and Karl attacked the UMA in an earlier version of FreeBSD (using a regular heap-overflow vulnerability in a sample module) [ak09], we overrode this metadata, successfully gaining code execution with kernel context. The attack is not unique to the FireWire driver and is applicable to any driver that maps a small variable allocated using UMA. During the initialization of FreeBSD’s FireWire driver, it allocates a dummy ORB that is sometimes required according to SBP-2 protocol (ORB is explained in Section 2.2). As a result, there is a 4-byte integer that is always allocated using UMA and is mapped at a fixed IOVA. Since UMA saves the metadata of pages with 4-byte objects on-page, it is accessible by the device. This metadata structure contains pointers to other structures with a few levels of indirection; one of them contains several pointers to functions. In particular, we used a destructor that UMA calls during object freeing. The specific hierarchy is inherited from the UMA design, and can be found in [aA10]. Using these metadata structures, we implemented a proof of concept by overriding only the necessary pointers to finally get the destructor points to an address in the same mapped page and set a simple payload there that is built only from int3 (debugger break-point opcode). As we did for the Linux FireWire attack, we got the virtual address of the page—which we needed for setting up the pointers—from the us data field in the original metadata structure, which points to the first item in the slab. When we disabled standard kernel protections, we successfully got an unexpected break-point error.