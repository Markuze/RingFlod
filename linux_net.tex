\section{\compound{} DMA attacks}\label{sec:linux_net}
\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{figs/page_frag.pdf}
    \caption{Allocation of B bytes from page\_frag}
    \label{fig:page_frags}
\end{figure}

So far, we have discussed how a malicious device can take over a machine by exploiting type (a) \subpage{} vulnerability of the FireWire driver. In this section we explore new attacks on the Linux network stack; where \means{} and \oportunity{} 
are initially missing but are attainable via compound steps, leaving room to dangerous privilege escalations attacks.

\subsection{\shinfo}
\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figs/ubuf.pdf}
    \caption{Using \shinfo{} to execute arbitrary code in kernel context.}
    \label{fig:sh_info}
\end{figure}

Struct \skb{} is a common data structure, used by the Linux network stack, to hold information representing a network packet. Struct \skb{} holds the metadata of a network packet (e.g., its size, associated socket). One of these fields is a pointer to a data buffer. The data is allocated separately, and thus, does not share a page with its \skb{} (Fig. \ref{fig:sh_info}). 

This separation means that \skb{} is \emph{never} (intentionally) mapped to the device. Indeed, it is a common belief, pointed out in literature \cite{thunder}, that the Linux network stack is not susceptible to DMA attacks via the \texttt{data} pointer. In this work, we show that this belief is misplaced.

The Linux network stack supports packet cloning by merely copying \skb{} metadata. This includes the \texttt{data} pointer. That is, the resulting \skb{} and the original one share the data buffer \cite{drivers2005linux}. Note that the \texttt{data} buffer of the \skb{} is the \emph{linear} part of the payload but \skb{} also supports \emph{non-linear} buffers, i.e., buffers described by their \page{}, length and offset in the \texttt{frags} array of \shinfo (Fig. \ref{fig:sh_info}). 

To support these non-linear buffers, the \shinfo{} metadata structure is used.
Struct \shinfo{}, in contrast to \skb{}, is always allocated as part of the data buffer. Therefore it is always mapped to the device. \shinfo is unwittingly mapped with the permissions of the packet, i.e., WRITE for RX packets, READ for TX packets, and in some cases, such as XDP/XSK \cite{xdp} with BIDIRECTIONAL.

Consequentially, \shinfo{} is the potential \oportunity{} the malicious device has been looking for. The \subpage{} vulnerability created by \shinfo{}, represents a type (b) vulnerability (Fig. \ref{fig:colocation} (b)), as this is innate to Linux networking rather than a driver security bug. 

Fig. \ref{fig:sh_info} depicts how a malicious device can mount an attack using \shinfo{} in four steps:
\begin{enumerate}[label=(\alph*)]
    \item An RX \skb{} and its data buffer are allocated. The data buffer is mapped for the NIC with WRITE access (the WRITE access is to the whole 4~KB page). 
    \item \texttt{destructor\_arg} field in \shinfo{} is overwritten to point within the mapped page. Now, the \texttt{destructor\_arg} is pointing to struct \uarg{} which is created by the NIC.
    \item \uarg{} has a callback pointer that is now pointing to the malicious code that resides on the same page. In the case of NX-bit, it is a poisoned ROP stack.
    \item when the \skb{} is released, the callback is invoked.
\end{enumerate}
To expand this scenario into a complete attack, the attacker must complete the MMO trifecta. That is, both \means{} and \oportunity{} are required. In the next subsection, we demonstrate how an attacker can leverage standard OS behavior to obtain the missing attributes.

\subsection{Hacking~\oportunity{}}\label{sec:shinfo}

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figs/road_to_op.pdf}
    \caption{Different ways to obtain \oportunity.}
    \label{fig:road_to_op}
\end{figure}

We now detail the different ways in which a malicious device can obtain \oportunity{} (Fig. \ref{fig:road_to_op}).

\begin{enumerate}[label=(\roman*)]

\item Presumably, a correct use of the DMA API should thwart the attack outlined in the previous section (Fig. \ref{fig:sh_info}). Namely, unmapping the buffer and only then initializing \shinfo{} should allow the CPU to undo any malicious changes the NIC may have perpetrated. 
As it turns out, prevalent device drivers (Appendix \ref{apndx:wrong_order}) first create an \skb{} and only then unmap the buffer. This order of execution allows the \emph{device} to undo legitimate changes to \shinfo{} by the CPU. 

\item Nevertheless, even when the order is correct, i.e., the unmapping of the buffer occurs before the creation of the \skb{}, still \shinfo{} is not safe from later modifications. As the default IOMMU mode in Linux is \emph{deferred} protection (Sec. \ref{sec:deferred}), the unmap order is made irrelevant. That is, even though the unmap function is invoked in the correct order, the device can still corrupt \shinfo{} due to the IOTLB. Namely, the device can control which \iova{} are cached in the IOTLB by accessing only the addresses it needs cached. 

\item In response, a security-conscious admin may change the default setting to \emph{strict} mode, where the IOTLB is flushed on every unmap. However, this both severely degrades networking performance \cite{MMT16,MSMT18}, and does not alleviate the security threats on the system. Presumably, with \emph{strict} mode enabled, the \iova{} the NIC used to access that \shinfo{} is no longer valid, which initially sounds promising. The problem is that the device, in many cases, will still have legitimate WRITE access to the physical page of the \shinfo. The vulnerability stems from the way \data{} is allocated. An RX \skb{} is almost exclusively allocated via an API (e.g., \texttt{napi\_alloc\_skb} or \texttt{netdev\_alloc\_skb}) that creates a type (c) \subpage{} vulnerability (Fig. \ref{fig:colocation} (c)). The device can use the \iova{} of a co-located buffer to access the \shinfo{} it requires. Particularly, the buffers of the driver RX ring are allocated sequentially, resulting in pairs of successive RX descriptors that map the same page. Obviously, this holds as long as the buffer sizes are smaller than 4 KB. This is a reasonable assumption since the default MTU size is 1500~B. These allocation functions, use a \texttt{page\_frag} mechanism to allocate the \data{} buffers, which in turn contain \shinfo. The \texttt{page\_frag} is an efficient method for allocating small buffers, often used by the Linux network stack, used 441 times by network drivers in Linux kernel 5.0. A \texttt{page\_frag} is initialized by allocating a contiguous memory region (usually 32 KB), setting a \textit{va} pointer to the beginning of the region and \texttt{offset} to the end. An allocation request for \texttt{B} bytes subtracts \texttt{B} bytes from the \texttt{offset} pointer and returns the new value of \texttt{offset}\footnote{In multicore environments, the \texttt{page\_frag} uses a different buffer for each CPU and each CPU has a single RX ring. As a result, each RX ring is served by its own (per-CPU) contiguous buffer.} (Fig. \ref{fig:page_frags}). This mechanism for memory allocation is efficient, but results in consecutive \data{} buffers sharing memory pages. Due to this type (c) \subpage{} vulnerability, the NIC does not require the invalidated \iova{} to modify the \shinfo; instead, it can use the \iova{} for the next data buffer. Note that the lower 12 bits (the offset on the page) of the \iova{} are identical to the corresponding \kva{} bits. As illustrated in Fig. \ref{fig:sh_info}, the \oportunity{} obtained is via the next buffer (i.e., the striped area at the end of the page).
\end{enumerate}

\noindent\textbf{Our setup.} tg3 and mlx5\_core are both vulnerable. The tg3 driver uses the correct unmapping order, but uses the \texttt{netdev\_alloc\_frag} function that results in a type (c) \subpage{} vulnerability. The mlx5\_core driver avoids unmapping the RX buffers altogether. In kernel 5.0, the driver uses a \texttt{page\_pool} mechanism\cite{page_pool} and in kernel 4.15, the driver uses an ad-hoc mechanism to achieve the same goal as \texttt{page\_pool}. These design choices, in both cases, leave \shinfo{} vulnerable, regardless of the OS IOMMU policy (\emph{deferred} or \emph{strict}). 


\smallskip
Interestingly, as it stands today, it seems that the only way to secure \shinfo{} is to never map it. Finally, from this point on, we assume that the attacker has unimpeded access to \oportunity{}. In the next subsections, we demonstrate various compound DMA attacks where an attacker can exploit OS behavior  to gain \means{} and \motivation{} completing the trifecta.

\subsection{Ring Flood}\label{sec:ringflod}

A malicious device can generate a poisoned ROP stack on each RX buffer and gain \motivation{}. At this point, the device still cannot execute a successful code injection attack; the device is lacking \means{}. 

Due to the IOMMU, the device has all the \iova{} for the RX buffers, but not the \kva{}. In this attack, we take advantage of the fact that the boot process is \emph{deterministic}. Each reboot, the same set of commands is executed in the same order initiating the same kernel modules and starting the same processes. While the pages each module receives may vary in a multi-core environment due to timing issues, the drift is not expected to be too large. 

\noindent\textbf{Our setup.} We evaluate this assumption on our setup running 256 reboots on Ubuntu 18.04 with both kernel 5.0 and kernel 4.15.
We find that when looking at the mlx5\_core driver, many of the PFNs repeat in more than 50\% percent of reboots on kernel 5.0 and more than 95\% on kernel 4.15. We assume an attacker can gain access to an identical setup, and identify the most common PFN. Thus, an adversary with knowledge about the physical setup can deduce a valid \kva{} for one of the RX pages containing a \mabaf. This provides both \means{} and \motivation{}. Thus, the trifecta is complete and the malicious device is able to execute the attack as shown in Fig. \ref{fig:sh_info} (in this case, the \texttt{destructor\_arg} will most likely indicate a different page, but other than that, the attack scenario is unchanged).


The success chances of the RingFlood attack increase with the memory footprint of the device driver. Which ,in turn, depends on the NIC capabilites and the number of cores (number of RX rings) on the server. This means that such attacks have increasing changes of success on larger machines. 
For example, some NICs have a HW LRO capability\cite{mlx5_lro}, where a NIC can aggregate multiple TCP packets into a single TCP packet, larger than MTU (e.g., bnx2x, mlx5\_core). On drivers configured with these options, each RX buffer is 64~KB regardless of MTU. As a result, these drivers have a much larger memory footprint. Mellanox, mlx5\_core driver on kernel 4.15, enables HW LRO and as a result allocates 2GB of memory per physical device port on a 32 core machine, on kernel 5.0 HW LRO is disabled, allocating just 2KB per entry and thus only 64MB per port. and are much easier to target with a RingFlood attack.

\begin{figure*}[t]
    \centering
    \includegraphics[width=\linewidth]{figs/accomplice.pdf}
    \caption{A TX sk\_buff filled with malicious code used as \means{} for a DMA attack.}
    \label{fig:payload}
\end{figure*}
\subsection{Poisoned TX}\label{sec:posion}

RingFlood (Section \ref{sec:ringflod}) allows a NIC to execute arbitrary code with high chances of success. However, the prerequisite is enough information regarding the physical layout of the server and a sufficiently high driver memory footprint. When deducing a valid PFN is not an option due to a low memory footprint, another way of acquiring a valid \kva{} is needed.

\smallskip
Since a NIC has READ access to the \shinfo{} of a TX packet, this, in particular, provides the NIC with READ access to the \texttt{frags} (Fig. \ref{fig:payload}) array which is a part of \shinfo{}. This array contains \page{} pointers, and thus both leaks kernel pointers that allow the attacker to compromise KASLR, and provides the PFNs of specific pages containing data sent from the userspace; pages, the device has READ access to.

\smallskip
Assuming an unprivileged accomplice (witing or unwitting) can open a UDP/TCP socket in user space, this user can transmit a poisoned ROP buffer. For a ROP attack (where the Kernel text offset is required), the NIC spoofs an RX packet with the poisoned ROP stack to the accomplice, which in turn is sent back as a TX packet. 

Once an accomplice sends the packet the NIC, the device can execute a code injection attack in 4 steps (Fig. \ref{fig:payload}):
\begin{enumerate}
    \item The TX \data{} and the fragments are mapped for the NIC to read.
    \item The NIC spoofs an RX packet and delays the completion notification of the TX packets (so that the \mabaf{} will not be released prematurely).
    \item The NIC identifies the poisoned buffer and translates \page{} to \kva{} (Fig. \ref{fig:mem_model}).
    \item The NIC overwrites \shinfo{} with the \kva{} retrieved during step 2. 
\end{enumerate}

A TX completion event that fails to appear in due time will trigger a TX T/O error that will flush all buffers and reset the driver; the T/O is set by the driver usually to a few seconds, which is more than enough to complete the attack.
 
In this scenario, the attacker does not require prior knowledge regarding the physical setup. In fact, the attacker only needs to gain \oportunity{}, as both \means{} and \oportunity{} are provided externally by the accomplice. 

Namely, the only requirement for the success of this attack is an accomplice, witting (e.g., an unprivileged user) or unwitting (e.g., a proxy server) that can open a socket in user-space. For that matter, a socket in user-space of a guest machine makes any cloud VM a valid intrusion tool in the presence of a malicious device.

\subsection{Forward Thinking}\label{sec:forward}

Packet forwarding is a standard Linux feature that allows a Linux machine to serve as a router or a load balancer. Packet forwarding functionality is usually disabled by default on Linux serves.

When this functionality is enabled, the NIC can independently generate an RX packet to a legitimate destination. This packet will then be forwarded to become a TX packet. However, unlike in the TCP layer that usually creates \skb{} packets with fragments, both the tg3 and the mlx5\_core drivers, usually create a linear \skb{}.

Namely, the drivers do not fill the \texttt{frags}, which the attacker uses to obtain \means{}. Both drivers, use the \texttt{napi\_gro\_receive} function to pass the \skb{} to the upper layer (this is the standard for most NIC drivers\footnote{Used by 98 NIC drivers, in Linux 5.0}). 

In this case, the upper layer is the Generic Receive Offload (GRO) layer \cite{gro}. GRO attempts to aggregate multiple TCP segments into a single large packet. Specifically, GRO converts multiple linear \skb{} buffers (belonging to a single TCP stream) into a single \skb{} with multiple fragments. This \skb{} then traverses the Linux network stack and becomes a TX packet. The attacker can use this TX packet as described in the previous attack (Fig. \ref{fig:payload}).

Packet forwarding, also opens up an additional attack option. An attacker might be interested in persistent surveillance rather than overtaking the machine. 

Packet forwarding allows the NIC to inspect arbitrary pages at will. 
Instead of sending a TCP packet and letting the GRO layer fill in the \texttt{frags} information, the NIC can generate a small UDP packet and fill in the \texttt{frags} array with any arbitrary \page{} addresses within the system. This makes the driver map these pages with WRITE, providing READ access to any page in the system to the NIC. Both the mlx5\_core and tg3 drivers map all the frags in \shinfo{} without verifying the actual packet length.

To avoid detection and, more importantly, preserve OS stability, the device must undo the changes to \shinfo{} before creating a TX completion. That is, before letting the CPU know that the packet was sent and its buffer can now be freed. Otherwise, the OS tries freeing the pages, indicated by \shinfo.

\smallskip
\noindent\textbf{Remark.} Having an accomplice in the form of an unprivileged user provides additional vectors of attack. In addition to running ROP attacks, the NIC can also leak the content of arbitrary memory pages to the user. Assuming that the NIC has WRITE access to \shinfo{} after it has been sent up the network stack (for example, in case of deferred protection or when page\_pool is used (see \ref{sec:xdp})), the NIC can modify the \page{} address in the \texttt{frag} entries, letting the Linux network stack copy the context of arbitrary memory pages to an unprivileged user. A likely side effect of this attack is memory corruption and Kernel panic, so caution is advised. The reason being, that the \texttt{skb\_free} function attempts to free these pages, pages never owned by the network stack.


\begin{figure*}[t]
    \centering
    \includegraphics[width=\linewidth]{figs/gro.pdf}
    \caption{An RX \skb{} after GRO used as a \means{} for a DMA attack.}
    \label{fig:gro}
\end{figure*}

\subsection{eXpress Data Path}\label{sec:xdp}

eXpress Data Path (XDP)~\cite{xdp} provides a way for users to add custom handling to RX buffers with little overhead. Common use cases include DDOS mitigation for security, forwarding and load balancing. To support the latter, the RX buffers are mapped with BIDIRECTIONAL access to the NIC. 

The tg3 driver does not support XDP. XDP support is usually added to high-speed NICs, such as ConnectX-4 (mlx5\_core). Accordingly, in this attack, we focus on the mlx5\_core driver, which, as mentioned in \ref{sec:forward}, does not unmap the RX buffers and reuses the pages using the page\_pool mechanism \cite{page_pool}. Subsequently, these pages are never unmapped, and remain accessible to the device for both reading and writing. 

The fact that the NIC has both read and write access to \shinfo, allows the NIC to execute an attack in 4 steps (Fig \ref{fig:gro}):
\begin{enumerate}
    \item An RX TCP packet is generated. Then, the \shinfo{} is initialised by the driver and the \texttt{frags} are filled with NULL pointers. Finally, the packet is handed to the next layer.
    
    \item A second RX \skb{} is generated as part of the same TCP stream, initialized and also handed to the next layer.
    
    \item Both packets reach the GRO layer. Then, the second \skb{} is coalesced with the first packet, the \skb{} is freed and the \data{} is added as a \texttt{frag} to the first \skb.
    
    \item The NIC reads the updated \texttt{frag} field and translates the \page{} address to a valid \kva{}. Finally, the device fills the \texttt{destructor\_arg} field, creating a poisoned \skb{} (Fig. \ref{fig:sh_info}).
\end{enumerate}

The difference between this flow and a regular receive flow is the additional read capability the NIC has due to XDP. That is, the last step, where \means{} is obtained, is possible only with READ access granted due to XDP.

\smallskip
\noindent\textbf{Remark.} Other drivers that support XDP, show similar behaviour\footnote{\textcolor{red}{Add a list of drivers to Appendix}}. Also, its important to note that the mlx5\_core driver has two modes of operation; linear - where an skb is built around an RX buffer and non-linear where the driver is is filling up the \texttt{frags} of \shinfo, which was never mapped. The former is the default, and the later is actually secure. The non-linear mode of option is secure because \shinfo{} is never accessible to the device; and thus the NIC never has the \oportunity{} to attack.

\begin{comment}
%The linear skbs in mlx5 are mapping sh\_info as BI\_DIR, need to see when linear used vs non-linear and to check othe XDP drivers. When sh\_info is mapped BI\_DIR its all we need to attack.\newline It seems linear skb (No (HW?)LRO and MTU<1500 : verify with experimnt or Boris) means no frags, while \begin{enumerate}
%    \item build\_skb is used on a mapped page
%    \item page is unmapped in a deferred way, regardless of iommu policy; a driver hack.
%\end{enumerate} 
 \begin{enumerate}
    \item skb\_try\_coalesce
    \item SW LRO/GRO
\end{enumerate}.
\newline
\textcolor{magenta}{In addition reviewing other drivers for the intersection of DMA\_BIDIR \^ (skb\_add\_rx\_frag||skb\_fill\_page\_descriptor)}
\end{comment}




