\section{Discussion on possible mitigations}
\subsection{Shadow buffers}
 Markuze et al. suggested that IOMMU driver should use bounce buffers [MMT16]. Normally, device drivers invoke map/unmap requests for desired buffers through the DMA API. According to their suggestion, instead of dynamically mapping/unmapping pages, the DMA back-end would copy the buffer to/from designated pages with fixed mapping. By keeping separate data pages for each device, they avoid data colocation and, as a result, eliminate the sub-page granularity vulnerability. Since the mappings are static, the issue of deferred invalidation is eliminated as well. The advantage of this solution is that all code changes are centralized in the DMA layer. Nevertheless, this solution imposes huge overheads of data copying. In a later work, Markuze et al. suggested reducing these overheads by implementing the DMA-Aware Malloc for Networking (DAMN) [MSMT18]. DAMN allocates memory directly from the fixed-mapping pages, so there is no need to copy the buffers back and forth. 
\subsection{Removing \shinfo}
One possible solution is to decouple \shinfo from the linear part of skb, but this solution will add an additional layer of complexity into the Linux network stack; and issues like the Firewire attack and/or any other bugs where data is mapped along with metadata will create new vulnerabilities. 
\subsection{Additional Mitigations}
Intel control flow enforcement technology (CET) is a new instruction set for mitigating ROP attacks [Int17]. Processors that support CET use two stacks simultaneously instead of the regular one, with the new shadow stack having only return addresses rather than a full copy of the data. During each RET command, the address in the shadow stack is checked and the code continues running only if the stacks agree on the address. Even if an attacker manages to control the regular stack, the shadow stack prevents the attack. In addition, each legitimate indirect jump target is marked with a special instruction. Thus, it is impossible to jump to arbitrary locations in the code and JOP attacks are also prevented. Similarly, each legitimate call target is also marked. De Raadt recently announced the Kernel Address Randomized Link (KARL) for FreeBSD as a software mitigation [dR17]. Each time the system is booted, it links a new, randomized kernel binary. This is true randomization (as opposite to Linuxâ€™s kASLR), making it impossible to patch the payload during runtime. Both KARL and CET will successfully mitigate simple ROP/kASLR attacks whenever widely applied.