

\section{Discussion and Conclusions}

\adam{consider separating discussion (the API talk, proposed defenses) into its own section, and have Conclusions for the summary and meta discussion.}

Once a malicious device exists, launching a DMA attack boils down to connecting the device to an external port and only for a few seconds. Furthermore, recent leaks from clandestine agencies show that they have attacked by both shipping infected hardware~\cite{Gal14} and connecting external malicious devices~\cite{Fin14}. Namely, no DMA attack could work without the unintentional exposure of restricted fields.\adam{huh? how is the former sentence connected to what comes before it?}

\begin{comment}
\footnote{\url{https://lore.kernel.org/lkml/20180510230948.GF190385@bhelgaas-glaptop.roam.corp.google.com/}}.
\end{comment}

As we demonstrate in this paper, the blame is not with the device drivers alone, rather, more often it is the OS design choices that open up the system to DMA attacks. With the existing API used for I/O operations and due to performance considerations, it is extremely difficult not to create a \subpage{} vulnerability. Thus, even well-written drivers can be subverted by the OS (e.g., bnx2 by deferred protection). Examples to this include:

\begin{enumerate}
    \item API: 
    \begin{itemize}[wide, labelwidth=!, labelindent=0pt]
        \item The \textit{dma\_map\_single} call accepts a pointer and the buffer length. This API insinuates that only the mapped bytes are exposed, when, in fact, the whole page is accessible.
        \item \textit{dma\_unmap\_single}, insinuates that the buffer is not accessible to the device after the call. This does not hold both due to deferred protection and type (c) \subpage{} vulnerabilities.
        \item \textit{build\_skb} facilitates building an \skb{} around an arbitrary I/O buffer, in turn, embedding critical data structures inside an I/O buffer.
        \item While \texttt{page\_frag} is an efficient allocator, it inherently creates a type (c) \subpage{} vulnerability.
    \end{itemize} 
    \item Tools/Infrastructure: 
    \begin{itemize}[wide, labelwidth=!, labelindent=0pt]
            \item \texttt{page\_pool} API, by caching I/O buffers and avoiding expensive unmaps, the drivers \emph{circumvent} the security techniques of the OS. 
            \item \shinfo{} is by design built within an I/O buffer. Avoiding type (b) \subpage{} vulnerabilities imposes a challenge.
            \item No dedicated allocates for I/O such as proposed in previous works (e.g.,~\cite{MSMT18,MMT16}).
    \end{itemize}
\end{enumerate}

We contend that a better API and better mechanisms can provide driver authors with better options for writing secure and performant device drivers.\adam{Reviewers, especially in EuroSys, will probably want to see a proposed API.} Specifically, for \shinfo{}, which is ingrained in the Linux network stack, we suggest the use of pointer obfuscation (similarly to MacOS), and solely non-linear RX buffers as an alternative to a new design. 

\subsection{\textcolor{red}{Early detection of DMA vulnerabilities}}
We have demonstrated that due to sub-page vulnerabilities, IOMMU is not sufficient to protect the OS against DMA attacks. Segregating I/O memory from OS memory as proposed by Markuze et al.~\cite{MMT16,MSMT18} is a possible direction towards providing security and performance. Additionally, we urge the use of analysis tools that detects \subpage{} vulnerabilities and offer \tool{} and \dkasan at the development and deployment stages to validate the security of the system.
%\smallskip
%\textcolor{olive}{Its important to note, that while our static analysis tool is able to flag potential \simple vulnerabilities fairly easily; the tool has trouble \compound attacks, due to the complexity of the kernel. This work also does not claim to cover all possible \compound attacks, and only provides a glimpse at the possible. Several attacks we have considered, but were not able to implement. We could modify the \emph{accomplice} attack, in a way that the user send a callback pointer in user space instead of a ROP attack, this attack unfortunately doesn't work due to Kernel smep/smap defences. Another attack; can exploit attempt exploiting ICMP packets. In the ICMP code we have noticed that RX skbs can be reused as TX skbs in ICMP replies. Eventually, we couldnt generate a flow that fill force such a reuse; this might just be because of lack of trying on our part. Forcing such a scenario is helpful to an attacker, with write access to \shinfo{}, for a TX packet can create a scenario allowing a memory dump just like we have shown.... :(- All Ive got... }

%\SV{modified... still requires some work}

%It is also important to note that while our static analysis tool is able to flag potential \simple{} vulnerabilities fairly easily, the tool is less efficient in detecting a potential to \compound{} attacks, mainly, due to the complexity of the kernel. That is, while the tool detects potential trifecta members, there is a need for a human expert to analyze the findings. 

%This work also does not claim to cover all possible \compound{} attacks, and only provides a glimpse at the possible using the trifecta principle. 

%That are also several attacks that we have considered but were not able to successfully execute: (1) we attempted to modify the \emph{accomplice} attack in a way that the user sends a callback pointer in user space instead of a ROP attack. This attack fails due to the Kernel smep/smap defences; (2) we attempted to exploit ICMP packets. In the ICMP code we have noticed that RX skbs can be reused as TX skbs in ICMP replays. Eventually, we could not generate a flow that fill force such a reuse. \SV{next sentence is unclear}Forcing such a scenario is helpful to an attacker, with write access to \shinfo{}, for a TX packet can create a scenario allowing a memory dump.

%The MMO schema covers both random and deterministic attacks. 
%In this paper, we focus on demonstrating and addressing deterministic attacks, where the attacker is able to deduce the layout of the targeted data structure and its location on a page. 
%Random access attacks, also exploit the sup-page vulnerability and should not be taken lightly. Successful execution of random access attacks requires a more in-depth analysis to produce a viable chance of success. Accordingly, in Sec.~\ref{sec:dma-kasan}, we present a run-time analysis tool capable of identifying such vulnerabilities. \adam{if there's a whole section about it, why the disclaimer that the paper focuses on deterministic attacks?}

\subsection{\textcolor{red}{Other attacks - Integrate?}}
The focus of our work is on code injection attacks as they often have a much higher value for the attacker (e.g., get access to sensitive machines and data). 
However other high impact attacks may still be viable with only part of the vulnerability attributes. 
For example, a full memory dump.
%The MMO schema can be extended  for additional vulnerability analysis. For example, other high impact attacks, such as a full memory dump, may still be viable with only \means and \oportunity{} given.
%KASLR is designed to stop code injection attacks. This indeed holds as long as kernel pointers are not leaked, an assumption that is not valid for DMA capable devices. For example, an OS leaks kernel pointers to a NIC, on pages containing small TX buffers. A malicious NIC can even spoof seemingly legitimate packets (e.g., ARP, ICMP, ICMPv6) to trigger kernel pointer leakage.
%Both attack types use type (d) vulnerability to compromise KASLR. KASLR is designed to stop code injection attacks. This indeed holds as long as kernel pointers are not leaked, an assumption that is not valid for DMA capable devices. For example, an OS leaks kernel pointers to a NIC, on pages containing small TX buffers. A malicious NIC can even spoof seemingly legitimate packets (e.g., ARP, ICMP, ICMPv6) to trigger kernel pointer leakage. \textcolor{olive}{We demonstrate the risks associated with type (d) vulnerability in Sec.~\ref{fig:dkasan-report}.}
In this scenario, an attacker is able to modify the kernel control flow in such a way as to cause it to map arbitrary kernel addresses. Given write access to an I/O scatter-gather list, a malicious device can control which memory pages are mapped by the CPU to the device. This would result in a full memory dump.\adam{this subsection is very short and hard to follow, why is it needed? suggest expanding or deleting}
%\adam{description isn't clear: it's modifying control-flow, so is it a code injection attack?} 
%In order to achieve this, an attacker needs to modify a kernel pointer once before it is mapped and, for a second time before send (i.e., TX) completion in order to avoid memory corruption (Sec.~\ref{sec:linux_net}). 

%We demonstrate in Section~\ref{sec:linux_net}, how an adversary can take advantage of \emph{deferred} mode.