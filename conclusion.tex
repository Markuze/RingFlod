

\section{Discussion and conclusions}

Once a malicious device exists, launching a DMA attack boils down to connecting the device to an external port and only for a few seconds. Furthermore, recent leaks from clandestine agencies show that they have been attacked by both shipping infected hardware \cite{Gal14} and connecting external malicious devices \cite{Fin14}. Namely, no DMA attack could work without the unintentional exposure of restricted fields.

\begin{comment}
\footnote{\url{https://lore.kernel.org/lkml/20180510230948.GF190385@bhelgaas-glaptop.roam.corp.google.com/}}.
\end{comment}

As we demonstrate in this paper, the blame is not with the device drivers alone, rather, more often it is the OS design choices that open up the system to DMA attacks. With the existing API used for I/O operations and due to performance considerations, it is extremely difficult not to create a \subpage{} vulnerability. Thus, even well-written drivers can be subverted by the OS (e.g., bnx2 by deferred protection). Examples to this include:

\begin{enumerate}
    \item API: 
    \begin{itemize}[wide, labelwidth=!, labelindent=0pt]
        \item The \textit{dma\_map\_single} call accepts a pointer and the buffer length. This API insinuates that only the mapped bytes are exposed, when, in fact, the whole page is accessible.
        \item \textit{dma\_unmap\_single}, insinuates that the buffer is not accessible to the device after the call. This does not hold both due to deferred protection and type (c) \subpage{} vulnerabilities.
        \item \textit{build\_skb} facilitates building an \skb{} around an arbitrary I/O buffer, in turn, embedding critical data structures inside an I/O buffer.
        \item While \texttt{page\_frag} is an efficient allocator, it inherently creates a type (c) \subpage{} vulnerability.
    \end{itemize} 
    \item Tools/Infrastructure: 
    \begin{itemize}[wide, labelwidth=!, labelindent=0pt]
            \item \texttt{page\_pool} API, by caching I/O buffers and avoiding expensive unmaps, the drivers \emph{circumvent} the security techniques of the OS. 
            \item \shinfo{} is by design built within an I/O buffer. Avoiding type (b) \subpage{} vulnerabilities imposes a challenge.
            \item No dedicated allocates for I/O such as proposed in previous works (e.g., \cite{MSMT18,MMT16}).
    \end{itemize}
\end{enumerate}

We contend that a better API and better mechanisms can provide driver authors with better options for writing secure and performant device drivers. Specifically, for \shinfo{}, which is ingrained in the Linux network stack, we urge the use of pointer obfuscation \cite{Coo17}, and solely non-linear RX buffers as an alternative to a new design. Additionally, we urge the use of analysis tools that detects \subpage{} vulnerabilities and offer \tool{} and \dkasan as a starting point towards a more secure DMA.


%\smallskip
%\textcolor{olive}{Its important to note, that while our static analysis tool is able to flag potential \simple vulnerabilities fairly easily; the tool has trouble \compound attacks, due to the complexity of the kernel. This work also does not claim to cover all possible \compound attacks, and only provides a glimpse at the possible. Several attacks we have considered, but were not able to implement. We could modify the \emph{accomplice} attack, in a way that the user send a callback pointer in user space instead of a ROP attack, this attack unfortunately doesn't work due to Kernel smep/smap defences. Another attack; can exploit attempt exploiting ICMP packets. In the ICMP code we have noticed that RX skbs can be reused as TX skbs in ICMP replies. Eventually, we couldnt generate a flow that fill force such a reuse; this might just be because of lack of trying on our part. Forcing such a scenario is helpful to an attacker, with write access to \shinfo{}, for a TX packet can create a scenario allowing a memory dump just like we have shown.... :(- All Ive got... }

%\SV{modified... still requires some work}

%It is also important to note that while our static analysis tool is able to flag potential \simple{} vulnerabilities fairly easily, the tool is less efficient in detecting a potential to \compound{} attacks, mainly, due to the complexity of the kernel. That is, while the tool detects potential trifecta members, there is a need for a human expert to analyze the findings. 

%This work also does not claim to cover all possible \compound{} attacks, and only provides a glimpse at the possible using the trifecta principle. 

%That are also several attacks that we have considered but were not able to successfully execute: (1) we attempted to modify the \emph{accomplice} attack in a way that the user sends a callback pointer in user space instead of a ROP attack. This attack fails due to the Kernel smep/smap defences; (2) we attempted to exploit ICMP packets. In the ICMP code we have noticed that RX skbs can be reused as TX skbs in ICMP replays. Eventually, we could not generate a flow that fill force such a reuse. \SV{next sentence is unclear}Forcing such a scenario is helpful to an attacker, with write access to \shinfo{}, for a TX packet can create a scenario allowing a memory dump.