\section{Background}
In this section, we give the motivation for our new attacks by presenting classic DMA attacks, the IOMMU protection against them, and recent attacks that circumvent IOMMU.
\subsection{DMA Attacks}
Direct Memory Access (DMA),allows input and output devices (I/O devices) to transfer data to and from memory \cite{oC54} independently of the CPU. While DMA is essential for fast I/O transactions, it also provides ample opportunity for unmonitored and malicious activity by the attached peripheral i.e DMA attacks. Without the presence of an IOMMU, which will be discussed later, the system has no way of preventing a DMA-capable device from reading and writing any memory region; given that DMA transactions are not filtered and use physical memory addresses. If a device is compromised, an attacker can read sensitive data from memory and/or overwrite the OS code and data-structures to gain full control of the victim system. DMA attacks can be carried out using an external or internal DMA-capable device. Using an external device for DMA attacks is rather simple if the victim system has expansion ports, such as FireWire or Thunderbolt, which allow external devices to initiate DMA transactions. By connecting a programmable accessory or a remote machine to such a port; one can access  any memory region on the victim machine\cite{Dor04, Vol, MM, thunder}. In contrast, to carry out DMA attacks using internal devices, the attacker must gain control over the internal I/O device, and turn it into a malicious device that executes the attacker’s code. While using internal devices is more challenging for attackers, it allows the attacker to run long-lived and stealthy attacks. \footnote{It is important to note in this context that gaining control over an I/O device does not necessarily compromise the system if DMA attacks cannot be carried out}. To gain control over an I/O device, an attacker can exploit firmware bugs. These bugs can be well-known, as end-users are often slow in deploying firmware updates \cite{DPVL10},or zero-day vulnerabilities that are found by extracting and reverse engineering the firmware \cite{Ben17b}. Alternatively, certain attackers may be able to replace the device firmware with a malicious one \cite{ZKB13, NL14}, or even manufacture devices that appear to be legitimate but are in fact malicious at the circuitry level \cite{YHD16, thunder}. Studies have demonstrated that an attacker capable of issuing DMA transactions, can initiate various attacks, ranging from running keyloggers \cite{LKV13, SB12} to gaining full control over commodity OSs and hypervisors, including Windows \cite{AD10,thunder}, Linux, OSX \cite{Fri16, thunder}, Android \cite{Ben17b} and Xen \cite{Woj08}. DMA attacks are also commonly used for computer forensics. Tools such as Volatility \cite{Vol}, Inception \cite{MM}, GoldFish \cite{GA10} and FinFireWire \cite{Fin14} can extract target machine memory and unlock victim machines by patching the OS code. These tools are reportedly used by law enforcement agencies and recently open source research tools \cite{thunder}. As countermeasures for DMA attacks, studies suggested software-based protection techniques. These solutions tighten security against DMA attacks but do not prevent them. Address space layout randomization (ASLR), often used to protect against buffer overflow attacks, can complicate DMA attacks, but does not prevent them \cite{SB12}. Storing secret data in the CPU registers can prevent the secret data from being read directly by exploited devices \cite{MFD11, CZG15, Sim11}, yet does not prevent the devices from extracting the secret by modifying the OS memory \cite{BR12}. DMA attacks can be detected by monitoring the bus activity using hardware performance counters and finding anomalies between the expected and actual DMA activity \cite{Ste13}. This approach, however, requires modeling each device’s DMA activity \cite{Ste14}, which is arguably unreasonable.
\subsection{FireWire}
 FireWire (also IEEE 1394, i.LINK  by Sony and Lynx by Texas Instruments) is an external port that allows end devices to access DMA directly; making potential attacks much easier\cite{Fin14}. For the same reasons, we use FireWire as a base of all our attacks, either by attacking its driver directly or by using it as a part of our lab setup. Firewire was intended  to be a serial replacement for the parallel SCSI bus while (also) providing connectivity for digital audio and video equipment. The \spb (serial bus protocol \#2) was developed to allow the use of SCSI devices over Firewire. While Firewire is an old physical connector that no longer exists in modern computer systems, there are cables that allow seamless conversion between Firewire and Thunderbolt, which enables the use Firewire in modern setups. 
 \newline A SCSI connection consists of two “endpoints”: an “initiator” (=OS in our case), which initiates the SCSI session, and a “target” (=disk in our case), which waits for the initiator’s commands and provides the required I/O data transfers. MacOS supports boot it “target disk mode”, such that the Mac will act as a (SCSI target) disk when connected to another computer. When FireWire is used, then \spb will be used. Linux, also supports an implementation of a SCSI target, through “Linux-IO (LIO) Target”, which allows a running computer to act as a SCSI target. The SCSI commands may flow through different fabric modules/interconnects such as FC, FCoE, SBP-2 (IEEE 1394). As noted, we use the latter. \spb defines ORB (Operation Request Block) as the data structure that represents the initiator’s requests \cite{Joh98}. Of the many possible messages classified into different ORB formats; In this work, we are concerned only with “LOGIN”, a management ORB that initiates new connections. To connect to a target, the initiator sends a login request. When the target is ready, it fills the buffer that was pointed to by the request with a login response using DMA, and reports to the initiator that it has done so. This single DMA write is enough for a malicious device to attack a Linux machine. In other attacks, we used this DMA write as an entry point for the attack, issuing other DMA writes regardless of the original behavior.
 \subsection{IOMMU}
As software techniques cannot prevent DMA attacks, DMA access must be restricted through a hardware protection device. The most common mechanism for this purpose is the input/output memory management unit (IOMMU), which adds a level of indirection for DMA addresses \cite{WRC08,YZ15,SB12,MTF12}. IOMMU effectively forces peripheral devices to use virtual addresses; an \iova(I/O virtual address). These addresses are then translated into physical ones, according to architectural data structures that are configurable by the OS. Usually, and specifically in the x86 architecture, access rights are set and translations are performed in page granularity \cite{Int16b, AMD16}. 
%Inspired by the standard MMU in x86, the translations are set in a radix tree \footnote{\textcolor{magenta}{Not sure we need this figure (Figure 2.1 in Thesis)}}. 
IOMMU protects against DMA attacks by ignoring or faulting when devices initiate DMA transactions to virtual addresses not marked as present. To use IOMMU for protection, the OS maps in IOMMU only the pages that hold I/O buffers. When introduced over 40 years ago, IOMMUs were not tasked primarily with providing security \cite{DWT79}. IOMMUs were used to allow devices that did not support vectored I/O to write to contiguous virtual memory, which is non-contiguous in physical memory \cite{Chu96, WMM97}. IOMMUs enabled legacy devices that only supported limited address width to access high memory. More recently, IOMMUs were used to assign I/O devices directly to virtual machines while maintaining their isolation properties \cite{Int16b, AMD16}. Throughout this period, OS developers did not appear to consider protection against malicious devices very important. To date, for example, Windows 10 is the first Windows version that uses the IOMMU for protection \cite{Mic17}.
\subsection{Circumventing IOMMU}
The IOMMU is open to several new kinds of attacks whose goal is to eliminate its protection. The first type target bad IOMMU implementations and the second focus on wrong initialization of the IOMMU. An example of bad implementations is the lack of interrupts remapping in the first IOMMU versions. Without the ability to forward only legitimate interrupts to the correct virtual machine, malicious devices might also generate on the host other interrupts. Rutkowska and Wojtczuk attacked the Intel VT-d by creating fake interrupts at the host, successfully executing code thanks to a bug in the interrupt mechanism on Intel machines \cite{WR11}. An example of wrong initialization is enabling I/O devices before setting up the IOMMU. Morgan et al. attacked the IOMMU by overriding its tables during initialization \cite{MANK16}. Frisk used a similar approach for stealing Apple FireVault passwords \cite{Cim16}. Sang et al. used both methods for several attacks \cite{SLND10}. First, they exploited the ability of the Intel VT-d to reduce IOTLB overhead by distributing entries to compatible I/O devices. Using this ability, malicious I/O devices can report false entries in order to access protected memory areas. Second, they capitalized on the fact that old implementations of the IOMMU identified I/O devices by self declarations. Malicious I/O devices can spoof the ID of an innocent one in order to access its memory. Last, they demonstrated how malicious I/O devices might exploit memory sharing with other I/O devices. Such sharing could, for example, be a decision of the OS according to the hardware topology. The picture would not be complete without an overview of attacks that simply ignore the presence of the IOMMU. Beniamini attacked the iPhone 7 and Nexus 5/6/6P through their Wi-Fi chips \cite{Ben17a, Ben17b}. While Nexus phones do not use an IOMMU, iPhones do. Beniamini, however, attacked the CPU by exploiting a TOCTOU (Time of Check – Time of Use) vulnerability in the NIC driver. From an I/O point of view, all the DMA writes were still legal (i.e. only to buffers that are currently explicitly mapped to the NIC). Also, modern IOMMU/PCI architectures includes the address translation services feature (PCI ATS; aka Device-IOTLB) that allows peripheral devices to serve as their own IOTLB. This feature is very unsecure and, in fact, lets malicious devices bypass the IOMMU protection by providing fake translations. In this work, we assume that the IOMMU is working as expected, so that it is possible to write an OS from scratch that utilizes the IOMMU correctly. OSs, however, are rarely written from scratch, as doing so is a very complex task. Our attacks thus target the methodology used by all commodity OSs to utilize the IOMMU in the real world. We have ignored ATS as it is unsecure by design. We have pushed a pacth to the Linux kernel that allows disabling ATS 
\begin{comment}
\footnote{https://lore.kernel.org/lkml/20180510230948.GF190385@bhelgaas-glaptop.roam.corp.google.com/}.
\end{comment}
