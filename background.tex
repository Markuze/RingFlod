\section{Background}
In this section, we give the motivation for our new attacks by presenting classic DMA attacks, the IOMMU protection against them, and recent attacks that circumvent it.
\subsection{DMA Attacks}
Direct Memory Access (DMA),allows input and output devices (I/O devices) to transfer data to and from memory \cite{oC54} independently of the CPU. While DMA is essential for fast I/O transactions, it also provides ample opportunity for unmonitored and malicious activity by the attached peripheral i.e DMA attacks. Without the presence of an IOMMU, which will be discussed later, the system has no way of preventing a DMA-capable device from reading and writing any memory region; given that DMA transactions are not filtered and use physical memory addresses. If a device is compromised, an attacker can read sensitive data from memory and/or overwrite the OS code and data-structures to gain full control of the victim system. DMA attacks can be carried out using an external or internal DMA-capable device. Using an external device for DMA attacks is rather simple if the victim system has expansion ports, such as FireWire or Thunderbolt, which allow external devices to initiate DMA transactions. By connecting a programmable accessory or a remote machine to such a port; one can access  any memory region on the victim machine\cite{Dor04, Vol, MM, thunder}. In contrast, to carry out DMA attacks using internal devices, the attacker must gain control over the internal I/O device, and turn it into a malicious device that executes the attacker’s code. While using internal devices is more challenging for attackers, it allows the attacker to run long-lived and stealthy attacks. \footnote{It is important to note in this context that gaining control over an I/O device does not necessarily compromise the system if DMA attacks cannot be carried out}. To gain control over an I/O device, an attacker can exploit firmware bugs. These bugs can be well-known, as end-users are often slow in deploying firmware updates \cite{DPVL10},or zero-day vulnerabilities that are found by extracting and reverse engineering the firmware \cite{Ben17b}. Alternatively, certain attackers may be able to replace the device firmware with a malicious one \cite{ZKB13, NL14}, or even manufacture devices that appear to be legitimate but are in fact malicious at the circuitry level \cite{YHD16, thunder}. Studies have demonstrated that an attacker capable of issuing DMA transactions, can initiate various attacks, ranging from running keyloggers \cite{LKV13, SB12} to gaining full control over commodity OSs and hypervisors, including Windows \cite{AD10,thunder}, Linux, OSX \cite{Fri16, thunder}, Android \cite{Ben17b} and Xen \cite{Woj08}. DMA attacks are also commonly used for computer forensics. Tools such as Volatility \cite{Vol}, Inception \cite{MM}, GoldFish \cite{GA10} and FinFireWire \cite{Fin14} can extract target machine memory and unlock victim machines by patching the OS code. These tools are reportedly used by law enforcement agencies and recently open source research tools \cite{thunder}. As countermeasures for DMA attacks, studies suggested software-based protection techniques. These solutions tighten security against DMA attacks but do not prevent them. Address space layout randomization (ASLR), often used to protect against buffer overflow attacks, can complicate DMA attacks, but does not prevent them \cite{SB12}. Storing secret data in the CPU registers can prevent the secret data from being read directly by exploited devices \cite{MFD11, CZG15, Sim11}, yet does not prevent the devices from extracting the secret by modifying the OS memory \cite{BR12}. DMA attacks can be detected by monitoring the bus activity using hardware performance counters and finding anomalies between the expected and actual DMA activity \cite{Ste13}. This approach, however, requires modeling each device’s DMA activity \cite{Ste14}, which is arguably unreasonable.
\subsection{FireWire}
 FireWire (also IEEE 1394, i.LINK  by Sony and Lynx by Texas Instruments) is an external port that allows end devices to access DMA directly; making potential attacks much easier\cite{Fin14}. For the same reasons, we use FireWire as a base of all our attacks, either by attacking its driver directly or by using it as a part of our lab setup. Firewire was intended  to be a serial replacement for the parallel SCSI bus while (also) providing connectivity for digital audio and video equipment. The \spb (serial bus protocol \#2) was developed to allow the use of SCSI devices over Firewire. While Firewire is an old physical connector that no longer exists in modern computer systems, there are cables that allow seamless conversion between Firewire and Thunderbolt, which enables the use Firewire in modern setups. 
 \newline A SCSI connection consists of two “endpoints”: an “initiator” (=OS in our case), which initiates the SCSI session, and a “target” (=disk in our case), which waits for the initiator’s commands and provides the required I/O data transfers. MacOS supports boot it “target disk mode”, such that the Mac will act as a (SCSI target) disk when connected to another computer. When FireWire is used, then \spb will be used. Linux, also supports an implementation of a SCSI target, through “Linux-IO (LIO) Target”, which allows a running computer to act as a SCSI target. The SCSI commands may flow through different fabric modules/interconnects such as FC, FCoE, SBP-2 (IEEE 1394). As noted, we use the latter. \spb defines ORB (Operation Request Block) as the data structure that represents the initiator’s requests \cite{Joh98}. Of the many possible messages classified into different ORB formats; In this work, we are concerned only with “LOGIN”, a management ORB that initiates new connections. To connect to a target, the initiator sends a login request. When the target is ready, it fills the buffer that was pointed to by the request with a login response using DMA, and reports to the initiator that it has done so. This single DMA write is enough for a malicious device to attack a Linux machine. In other attacks, we used this DMA write as an entry point for the attack, issuing other DMA writes regardless of the original behavior.
 \subsection{IOMMU}
As software techniques cannot prevent DMA attacks, DMA access must be restricted through a hardware protection device. The most common mechanism for this purpose is the input/output memory management unit (IOMMU), which adds a level of indirection for DMA addresses \cite{WRC08,YZ15,SB12,MTF12}. The IOMMU effectively forces the device to use virtual addresses; an \iova(I/O virtual address). These addresses are then translated into physical ones, according to architectural data structures that are configurable by the OS. Usually, and specifically in the x86 architecture, access rights are set and translations are performed in page granularity \cite{Int16b, AMD16}. Inspired by the standard MMU in x86, the translations are set in a radix tree \footnote{\textcolor{magenta}{Not sure we need this figure (Figure 2.1 in Thesis)}}. The IOMMU protects against DMA attacks by ignoring or faulting when devices initiate DMA transactions to virtual addresses not marked as present. To use the IOMMU for protection, the OS maps in the IOMMU only the pages that hold I/O buffers. When introduced over 40 years ago, IOMMUs were not tasked primarily with providing security \cite{DWT79}. IOMMUs were used to allow devices that did not support vectored I/O to write to contiguous virtual memory, which is non-contiguous in physical memory \cite{Chu96, WMM97}. IOMMUs enabled legacy devices that only supported limited address width to access high memory. More recently, IOMMUs were used to assign I/O devices directly to virtual machines while maintaining their isolation properties \cite{Int16b, AMD16}. Throughout this period, OS developers did not appear to consider protection against malicious devices very important. To date, for example, Windows 10 is the first Windows version that uses the IOMMU for protection \cite{Mic17}.