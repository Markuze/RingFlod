\section{Background}
%\SV{restructure section: mention only high level details regrading the technical stuff... move FireWire lower level details to relevant section. Get rid of subsections...}
In this section, we give the motivation for our new attacks by presenting classic DMA attacks, the IOMMU protection against them, and recent attacks that circumvent IOMMU.

%\subsection{DMA Attacks}
\paragraph{DMA attacks}
Direct Memory Access (DMA),allows input and output devices (I/O devices) to transfer data to and from memory \cite{oC54} independently of the CPU. While DMA is essential for fast I/O transactions, it also provides ample opportunity for unmonitored and malicious activity by the attached peripheral i.e DMA attacks. Without the presence of an IOMMU, which will be discussed later, the system has no way of preventing a DMA-capable device from reading and writing any memory region; given that DMA transactions are not filtered and use physical memory addresses. If a device is compromised, an attacker can read sensitive data from memory and/or overwrite the OS code and data-structures to gain full control of the victim system. DMA attacks can be carried out using an external or internal DMA-capable device. Using an external device for DMA attacks is rather simple if the victim system has expansion ports, such as FireWire or Thunderbolt, which allow external devices to initiate DMA transactions. By connecting a programmable accessory or a remote machine to such a port; one can access  any memory region on the victim machine\cite{Dor04, Vol, MM, thunder}. In contrast, to carry out DMA attacks using internal devices, the attacker must gain control over the internal I/O device, and turn it into a malicious device that executes the attacker’s code. While using internal devices is more challenging for attackers, it allows the attacker to run long-lived and stealthy attacks. \footnote{It is important to note in this context that gaining control over an I/O device does not necessarily compromise the system if DMA attacks cannot be carried out}. To gain control over an I/O device, an attacker can exploit firmware bugs. These bugs can be well-known, as end-users are often slow in deploying firmware updates \cite{DPVL10},or zero-day vulnerabilities that are found by extracting and reverse engineering the firmware \cite{Ben17b}. Alternatively, certain attackers may be able to replace the device firmware with a malicious one \cite{ZKB13, NL14}, or even manufacture devices that appear to be legitimate but are in fact malicious at the circuitry level \cite{YHD16, thunder}. Studies have demonstrated that an attacker capable of issuing DMA transactions, can initiate various attacks, ranging from running keyloggers \cite{LKV13, SB12} to gaining full control over commodity OSs and hypervisors, including Windows \cite{AD10,thunder}, Linux, OSX \cite{Fri16, thunder}, Android \cite{Ben17b} and Xen \cite{Woj08}. DMA attacks are also commonly used for computer forensics. Tools such as Volatility \cite{Vol}, Inception \cite{MM}, GoldFish \cite{GA10} and FinFireWire \cite{Fin14} can extract target machine memory and unlock victim machines by patching the OS code. These tools are reportedly used by law enforcement agencies and recently open source research tools \cite{thunder}. As countermeasures for DMA attacks, studies suggested software-based protection techniques. These solutions tighten security against DMA attacks but do not prevent them. Address space layout randomization (ASLR), often used to protect against buffer overflow attacks, can complicate DMA attacks, but does not prevent them \cite{SB12}. Storing secret data in the CPU registers can prevent the secret data from being read directly by exploited devices \cite{MFD11, CZG15, Sim11}, yet does not prevent the devices from extracting the secret by modifying the OS memory \cite{BR12}. DMA attacks can be detected by monitoring the bus activity using hardware performance counters and finding anomalies between the expected and actual DMA activity \cite{Ste13}. This approach, however, requires modeling each device’s DMA activity \cite{Ste14}, which is arguably unreasonable.

%\subsection{IOMMU}
\paragraph{IOMMU}
With the lack of software protection against DMA attacks, the common practice is to restrict DMA accesses through a hardware protection device. The most common mechanism for this purpose is the input/output memory management unit (IOMMU), which adds a level of indirection for DMA addresses \cite{WRC08,YZ15,SB12,MTF12}. IOMMU effectively forces peripheral devices to use virtual addresses; an \iova(I/O virtual address). These addresses are then translated into physical ones, according to architectural data structures that are configurable by the OS. Usually, and specifically in the x86 architecture, access rights are set and translations are performed in page granularity \cite{Int16b, AMD16}. 
%Inspired by the standard MMU in x86, the translations are set in a radix tree \footnote{\textcolor{magenta}{Not sure we need this figure (Figure 2.1 in Thesis)}}. 
IOMMU protects against DMA attacks by ignoring or faulting when devices initiate DMA transactions to virtual addresses not marked as present. To use IOMMU for protection, the OS maps in IOMMU only the pages that hold I/O buffers. When introduced over 40 years ago, IOMMUs were not tasked primarily with providing security \cite{DWT79}. IOMMUs were used to allow devices that did not support vectored I/O to write to contiguous virtual memory, which is non-contiguous in physical memory \cite{Chu96, WMM97}. IOMMUs enabled legacy devices that only supported limited address width to access high memory. More recently, IOMMUs were used to assign I/O devices directly to virtual machines while maintaining their isolation properties \cite{Int16b, AMD16}. Throughout this period, OS developers did not appear to consider protection against malicious devices very important. To date, for example, Windows 10 is the first Windows version that uses the IOMMU for protection \cite{Mic17}.
% We have pushed a pacth to the Linux kernel that allows disabling ATS 

