\section{Background}

In this section, we provide the necessary background needed to discuss DMA related attacks. First, we describe classic DMA attacks and the IOMMU protection against them. Then, we discuss well-established protection practices against privilege escalation (i.e., code injection) attacks and methods of their circumvention.

\subsection{DMA attacks}

DMA allows I/O devices, direct access to memory \cite{oC54} without CPU involvement. While DMA is essential for fast I/O, it also provides ample opportunity for unmonitored and malicious activity by DMA capable devices, i.e., DMA attacks. 

An attacker can access sensitive data and/or overwrite the OS code and data-structures and even gain full control of the victim system. DMA attacks can be carried out using an external or internal DMA-capable device. Accessible expansion ports, e.g., FireWire or Thunderbolt, allow external devices to initiate DMA transactions merely by connecting a programmable accessory \cite{Dor04, Vol, MM, thunder}. 

Exploiting internal devices is more challenging, but allows for long-lived and stealthy attacks. Clearly, an internal device is simply less conspicuous than an external peripheral connected via a Thunderbolt cable.

Multiple options to gain control of an internal device are available.
A resourceful attacker can exploit firmware bugs \cite{SB12}. These can be well-known exploits, as end-users are often slow in deploying firmware updates \cite{DPVL10}, and even newly discovered zero-day vulnerabilities \cite{Ben17b}. Alternatively, certain attackers may be able to replace the device firmware altogether with a malicious one \cite{ZKB13, NL14}. It is also possible to manufacture devices that appear to be legitimate but are, in fact, malicious at the circuitry level \cite{YHD16}.

Once an attacker gained control over a DMA device connected to a victim machine, various attacks are possible; ranging from keyloggers \cite{LKV13, SB12} to full control over commodity OS and hypervisor, including Windows \cite{AD10,thunder}, Linux, OSX \cite{Fri16, thunder}, Android \cite{Ben17b}, and Xen \cite{Woj08}.

Several software tools for perpetrating DMA attacks exist, some are open source. Tools such as Volatility \cite{Vol}, Inception \cite{MM}, GoldFish \cite{GA10} and FinFireWire \cite{Fin14} can extract target machine memory and unlock victim machines by patching the OS code. These tools are reportedly used by government agencies, such as NSA.

\subsection{IOMMU}

With the lack of software protection against DMA attacks, the common practice is to restrict DMA accesses through hardware protection. The most common mechanism for this purpose is the I/O memory management unit (IOMMU). IOMMU adds a level of indirection for DMA addresses \cite{WRC08,YZ15,SB12,MTF12}, effectively providing peripheral devices with virtual addresses termed~\iova(I/O virtual address). This way, the device can access only these pages that the OS has explicitly allowed. Inspired by the x86 MMU, IOMMU uses a page table for address translation and an IO/TLB for caching recent accesses.  The page tables are managed by the OS and as in MMU, have a page granularity. The common page size is 4KB, though other larger page sizes, up to GBs, also exist.

The page table also holds page access rights for each \iova. An access right can be either READ, WRITE, or BIDIRECTIONAL. Note that WRITE access does not grant a DMA device read access, whereas BIDIRECTIONAL access is needed to both read and write from/to the page. It is also important to note that a single physical page can be mapped by multiple \iova, each with possibly a different access right.

IOMMUs were not designed primarily with providing security \cite{DWT79}. IOMMUs were used to allow devices that did not support vectored I/O, to access contiguous virtual memory, which may map non-contiguous physical memory \cite{Chu96, WMM97}. IOMMUs also enabled legacy devices that only supported limited address width (32bit), to access high memory (64 bit). More recently, IOMMUs were used to assign I/O devices directly to virtual machines while maintaining their isolation properties \cite{Int16b, AMD16}. Throughout this period, OS developers did not appear to consider protection against malicious devices important. To date, for example, Windows 10 is the first Windows version that uses the IOMMU for protection \cite{Mic17}.
