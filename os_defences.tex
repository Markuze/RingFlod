\subsection{OS Defences}

Other than DMA attacks, OS developers have to worry about code injection attacks from other sources, like buffer overflow attacks \cite{nx, kalsr}.
We discuss the common mechanisms used to mitigate such attacks in the kernel, regardless of attack origins. As subverting these countermeasures is essential to privilege escalation attacks by a malicious device.

\paragraph{NX-BIT.}\label{sec:nx-bit}
\begin{figure*}[t]
        \begin{lstlisting}[
        %basicstyle = \small,
        basicstyle=\ttfamily,
        columns = fixed,
        tabsize=8,
        %frame = l,
        language = C
        ]
==================================================================================
Start addr       |   Offset   |     End addr     |  Size   | VM area description
==================================================================================
...
ffff888000000000 | -119.5  TB | ffffc87fffffffff |   64 TB | page_offset_base
...
ffffe90000000000 |  -23    TB | ffffe9ffffffffff |    1 TB | ... unused hole
ffffea0000000000 |  -22    TB | ffffeaffffffffff |    1 TB |  vmemmap_base
...
ffffffff00000000 |   -4    GB | ffffffff7fffffff |    2 GB | ... unused hole
ffffffff80000000 |   -2    GB | ffffffff9fffffff |  512 MB | kernel text mapping
...
                \end{lstlisting}
        \caption{ Linux Kernel memory layout.}
        \label{fig:mem_layot}
\end{figure*}
A malicious device can inadvertently gain write access to a function pointer and consequently gain the ability to inject malicious code. 
To protect against such threats, modern OSs make use of hardware support, namely the No-eXecute bit, to prevent code execution from data pages. This bit is defined for each page in MMUâ€™s page tables. Whenever the CPU tries to fetch code from memory, this bit is validated. When set, the CPU raises an exception to the OS, instead of executing the code. The NX\-bit method is also known as the W xor X (Write xor eXecute) and DEP. 
A DMA capable device rarely has access to kernel text regions. Thus the NX\-bit is effective in preventing simple code injection attacks.

Return Oriented Programming (ROP) is a common method used by malware to bypass DEP (i.e., NX\-bit) defenses \cite{RBSS12}. ROP exploits the fact that the CPU stack pointer may point to any data page. To set up an attack from a data page, the attacker builds a poisoned stack filled with required data and pointers to specific locations in the code section (a.k.a., ROP gadgets). Each gadget is a short piece of code (usually one or two commands) and a return command. When the CPU executes a return command, the return address and thus the address of the next command to execute is taken from the stack. In the poisoned stack, each return address points to the next gadget and so on. 
 
By carefully selecting these gadgets, an attacker can execute any payload. To bootstrap a ROP attack, an attacker must modify the stack pointer register to the address of the poisoned stack. This is often achieved with another DEP circumventing technique, i.e., Jump Oriented Programming (JOP) \cite{BJFL11}. JOP uses, \texttt{jump} instructions instead of \texttt{return} instructions and, thus, does not require a poisoned stack.

\begin{figure*}[t]
                \begin{lstlisting}[
        basicstyle = \ttfamily,
        columns = fixed,
        tabsize=8,
        %frame = l,
        language = C
        ]
        
#define __va(x) ((void *)((unsigned long)(x) + PAGE_OFFSET))
#define __pa(x) ((unsigned long)(x) - PAGE_OFFSET)

#define virt_to_pfn(kaddr)      (__pa(kaddr) >> PAGE_SHIFT)
#define pfn_to_virt(pfn)        __va((pfn) << PAGE_SHIFT)

/* memmap is virtually contiguous.  */
#define __pfn_to_page(pfn)      (vmemmap + (pfn))  
#define __page_to_pfn(page)     (unsigned long)((page) - vmemmap)
                \end{lstlisting}
        \caption{ Linux kernel macros for translation between KVA, PFN and \page{}.
                }
        \label{fig:mem_model}
\end{figure*}

\paragraph{KASLR.}\label{sec:kaslr}

To successfully execute a code injection attack, the attacker must know the memory layout. Specifically, the address of the code section is required for finding ROP gadgets (section \ref{sec:nx-bit}). 

Address Space Layout Randomization (ASLR) is a common mechanism for mitigating code injection attacks in the context of user-level processes. Systems that support ASLR randomize the memory layout for each process on every execution. This way, ROP attacks built for a specific layout, fail. Similarly, KASLR \cite{kalsr} randomizes the kernel memory layout.

The Linux kernel has a predetermined virtual memory layout \cite{mem_layout}. This layout defines the location of the kernel text mapping, the direct mapping of physical memory and the virtual memory. KASLR randomizes their offsets each reboot.

Since KASLR randomizing only the base address of the kernel text mapping, text addresses always appear in the range \texttt{[0xffffffff80000000,0xffffffffa0000000)} (Fig. \ref{fig:mem_layot}) and, therefore are easy to detect. KASLR kernel text is aligned to 2MB borders; this is the result of page table restrictions and unlikely to change, which means that the lowest 21 bits remain unchanged. Hence, knowing even a single address of a known element is sufficient to deduce the base address and compromise KASLR; once the base address is known, the attacker can use it to create a ROP stack. To identify this first pointer, malicious devices can scan pages mapped for reading, looking for kernel pointers, leaked due to \subpage{} vulnerability. Once such a pointer is identified, all that remains is to reduce the offset of the symbol in the binary from the pointer to get the base address.

In fact, during our investigation, we have found that there is a symbol visible to both FireWire and NICs in all Linux versions we have tested (i.e., 4.4, 4.13, 4.15, and 5.0), making it suitable for compromising KASLR. Specifically, as of version 2.6.24, Linux supports network namespaces and every network object, and in particular, sockets have a pointer to their namespace object. One such object, namely a global namespace object, \texttt{init\_net}, is always defined. By scanning leaked pages during I/O and utilizing the fact that the lower 21 bits of the text region, as aforementioned, are never modified, we can identify \texttt{init\_net} with high probability.

As of Linux 4.8, the direct mapping base (\texttt{page\_offset\_base}) and virtual memory map (\texttt{vmemmap\_base}) are also randomized (Fig. \ref{fig:mem_layot}), where each regions base pointer is randomized respecting a 1~GB alignment. This means that the lower 30 bits are unmodified and can leak both the PFN numbers and the randomized offset. This alignment is also due to page table considerations; the page upper table (PUD) has a 30~bit shift. Once the random offsets \textit{PAGE\_OFFSET} and \textit{vmemmap} for direct mapping base and virtual memory map are known its possible to transition between a \kva(direct mapping region) its PFN and, its \page{} address(virtual memory map region). The translation macros are shown in Figure \ref{fig:mem_model}. 

