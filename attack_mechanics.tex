\section{Attack Mechanics}
Given that (1) the IOMMU hardware is correctly implemented, and (2) it is correctly initialized on time, one might assume that the systems are safe from DMA attacks. We contend that this is not the case. The least-privilege principle requires that an entity such as a software module or a physical device must always have only the minimum necessary access for operating normally. In this chapter, we describe the potential still-existing risks caused by software that violates this principle.
\subsection{Sub-Page} 
Currently, OSs allocate I/O buffer memory using the same mechanisms they use for any memory allocation. These mechanisms, however, are oblivious to the role of the allocated memory. Consequently, I/O buffers may reside in the same page with other and potentially sensitive data. Since IOMMU protection is limited to page granularity, I/O devices that are allowed to access an I/O buffer gain access to this data as well. This behavior might compromise the system security. We classified the different types of potentially colocated data into three categories (as illustrated in Figure 3.1): In case (a), the I/O buffer is part of a bigger data structure that also contains metadata used by the device driver. In the extreme case, this metadata might include function pointers, which enable relatively simple and robust attacks. Other fields in such data structures might be dangerous as well. In case (b), the memory allocator saves metadata, such as free-lists, with the I/O buffers, in the same page [Cor07]. Manipulating these data structures may compromise the system completely [ak09]. Finally, in (c), the I/O buffer and another dynamically allocated memory may reside in the same page. This common situation can easily cause data leakage, but may also be used for more sophisticated attacks. We used randomly colocated pointers to break kASLR, as we discuss in Chapter 5. Why do OSs ignore the disparity between I/O buffer allocation alignment and protection granularity? One possible explanation is the benefits of dense memory allocations: lower internal memory fragmentation, which results in higher memory utilization, and lower translation lookaside buffer (TLB) pressure, which reduces the number of TLB misses. We suspect, however, that the main reason for the disparity is actually more prosaic. As IOMMUs were introduced to commodity servers relatively recently, OS developers have been reluctant to overhaul existing device drivers and change the way they allocate and manage their memory. Instead, IOMMU mapping operations were abstracted from device drivers, and implemented on top of existing DMA APIs [MHJ, The]. As a result, the memory allocation of I/O buffers has not been modified and adapted to take into consideration the IOMMU protection granularity.
\subsection{Deferred Invalidation vulnerability}
To translate addresses efficiently, the IOMMU caches translations in an input/output
translation lookaside buffer (IOTLB). Like MMUs, IOMMUs do not maintain consistency
between the IOTLB and the IOMMU page tables, which reside in memory; instead, the
OS is required to restore consistency by explicitly invalidating the IOTLB. Therefore,
to ensure that the IOTLB never holds stale entries, the OS must invalidate the IOTLB
immediately after it removes memory mappings.
Yet this scheme, called the “strict” mode in Linux, can degrade performance, as
IOTLB invalidations can induce very high overhead. In I/O intensive workloads, the
number of required IOTLB invalidations can be extremely high, as IOMMU entries
are unmapped following each I/O operation. Moreover, the overhead of each IOTLB invalidation can be as high as 2000 cycles [ABYTS11], considerably more than TLB
invalidation, which takes roughly 100 cycles [Han14].
To reduce this overhead, Linux defers TLB invalidations by default, and instead
performs periodic global TLB invalidations. This “deferred” mode induces smaller
performance overheads relative to the alternative “strict” mode. Nevertheless, as
depicted in Figure 3.2, deferring IOTLB invalidations may not prevent I/O devices
from accessing unmapped pages, as the IOMMU may perform translations using stale
IOTLB entries until the actual invalidation.
This behavior introduces a security hazard, as the OS can reuse pages for other
purposes after they are unmapped, regardless of the actual time of IOTLB invalidation.
In the time window between the unmap operation and the actual invalidation, the
OS may place sensitive data in the unmapped page-frame. In fact, this is a common
scenario, as OSs prefer to reuse “hot” page-frames, recently freed, as they are likely to
be already cached in the CPU caches. Therefore, it is possible in certain cases to predict
how unmapped memory would be reused and which data it would accommodate. As we
demonstrate in Section 4.3, this behavior enables us to build robust assaults powerful
enough to gain full control over a victim system.
\subsection{Threat Model}
Our attacks are built on the following assumptions:
1. The actual attack is performed by a DMA-capable malicious device. Devices with
only read access may still launch some attacks but they are generally weaker.
2. There is software that violates the least-privilege principle with respect to the I/O
device. The inherent vulnerabilities in the common use of the IOMMU make this
a realistic assumption (§3.1).
3. Physical access to the victim may be required depending on the type of device (§3.3).
The attacks discussed in this work are not executed by modifying the victim’s OS or
drivers. We also assume that any hardware aside from the specific malicious device is
working as expected, especially the DMA controller and the IOMMU itself. We also do
not consider ports intended for debugging (e.g., jtag).
\subsection{Consequences}
The greatest potential consequence of our attacks is privilege escalation, which allows
attackers to execute arbitrary code with kernel privileges. In all our experiments, we
successfully executed code in the context of the kernel. Another potential consequence
of our attacks is denial of service. Ideally, malformed devices should not be able to
crash the entire system. The IOMMU is expected to properly isolate the devices from
the OS to ensure this does not happen. Bad isolation, such as colocation of different
types of data in the same page, may lead to system instability.
To reach the above results, the attacker must have write permissions to some memory
region. When an attacker only has only read permissions, the consequences may still be
interesting as they may lead to data leakage. The kernel often keeps sensitive data such
as encryption keys and passwords as plain-text in memory. Attackers may use incorrect
read permissions to leak this sensitive data.