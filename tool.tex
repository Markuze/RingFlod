\section{Static Code Analysis Tool}\label{sec:static-analysis}

Inspired by the MMO schema, we devise a static code analysis tool (\tool) to identify vulnerabilities to DMA attacks. With well over a 1000 \texttt{dma\_map*} (i.e., the set of functions implementing the DMA API) function calls, in the Linux Kernel, a manual process would be arduous. \tool flags drivers where \oportunity{} is present. In the case of I/O devices \motivation{} is usually trivial as the device has legitimate write access and can freely write a poisoned ROP stack in any legitimate write accessible buffer. \means{}, is often hardest to identify and calls for human expertise. \tool looks for \texttt{dma\_map*} functions and traces back the call stack to identify if the mapped buffer is embedded inside a data structure (Fig. \ref{fig:colocation} (a)). Additionally we look for potentially hazardous functions (e.g., \texttt{build\_skb}), that create a data structure inside a mapped buffer (Fig. \ref{fig:colocation} (b)). 
%The risk is classified according to the access permission. \means{} is implied by a READ permission and \oportunity{} is implied by a WRITE/BIDIRECTIONAL permission. 
The case of multiple \iova{} (Fig. \ref{fig:colocation} (c)), is also flagged by \tool, which flags use of functions (e.g., netdev\_alloc\_skb, napi\_alloc\_skb) that may result in this type of vulnerability or any other function that uses the page frag api. 

Currently, human expert input is needed to determine which functions are truly \emph{hazardous}. As a result \tool determines type (a) vulnerabilities automatically and types (b) and (c) only with sufficient human expert input. 

%The output of the tool presents structured and filtered findings conductive for more in-depth human expert analysis to determine if a viable attack is feasible. 

Type (d) vulnerability falls under the category of random access and discussed further in  Sec.~\ref{sec:dma-kasan}.

\subsection{Design}
\tool operates recursively starting from a set of \textit{root functions} (e.g., dma\_mag\_single) (i.e., collecting all the function calls). \tool utilises Cscope \cite{cscope,cscope_92} to navigate the Kernel code. Cscope is an open source tool for browsing C source code. From this initial set of calls, \tool identifies the mapped variables and backtracks their declarations and assignments to these variables. When a data structure is identified as exposed, \tool searches
exposed callback pointers or mapped heap pointers. \tool also utilises \texttt{pahole} \cite{dwarves} to explore the compiled binaries for the layout of the exposed data structures. Pahole, is a tool that uses the DWARF \cite{dwarf} standardized debugging data format to examine data structure layout.

\tool is applicable to any Kernel code written in C. We intend to make the \tool publicly available for benefit of the research community.

%The algorithm performs the following:
%\begin{enumerate}
%    \item Identify the mapped variable.
%    \item Locate variable declaration
%        \begin{itemize}
%            \item Identify biggest enclosing data structure that is mapped.
%            \item If callbacks located stop.
%        \end{itemize}
%    \item Locate Relevant assignments. For each:
%        \begin{itemize}
%            \item In case variable is assigned from new var restart from 2. 
%            \item in case of allocation: stop.
%        \end{itemize}
%    \item If declaration is reached:
%        \begin{itemize}
%            \item If function Call: Locate all calls and return to 1.
%            \item If on heap - check if heap is mapped: stop.
%        \end{itemize}
%\end{enumerate}

\subsection{Analysis and Results}
We use \tool over Linux Kernel 5.3 code,
analysing 1019 dma\_map\_single calls over 447 files. We present the results in table \ref{tab:static_analysis}. We dedicate special attention to struct \shinfo, which is used ubiquitously in Linux networking. This data structure is \textit{always} located on the same page as the \texttt{skb->data}, and it also contains a callback pointer. We discuss the vulnerabilities related to \shinfo in Sec. \ref{sec:linux_net}. We find that more than 50\% of the dma-map calls expose \shinfo either by directly mapping the \texttt{skb->data} or via the \texttt{build\_skb} API (lines 2 \& 7 in Fig. \ref{tab:static_analysis}). The OS provides this data structure layout and API rather than being an isolated driver bug. Additionally, we find 19 data structures that are exposed via APIs that store \texttt{private} data structures on the same page as vulnerable meta-data, e.g., netdev\_priv, aead\_request\_ctx and scsi\_cmd\_priv. We find 156 cases in which device drivers inadvertently expose callback pointers. Of these, 54 are cases where the pointers are exposed directly, and the rest are cases where callback pointers can be spoofed.\footnote{In this case, spoofing means replacing this pointer to indicate an instance of the structure created by the device, with its own callback pointers.}
%(i.e., a pointer to a data structure which contains callbacks is exposed).
%\adam{unclear what pointer spoofing means, and why having a pointer to a data structure with a callback is useful. Is the ? Need to say this explicitly}
Our analysis also finds three instances where the stack pointer is mapped
%\adam{the table says ``heap mapped'', not stack}.
In addition to exposed callback pointers, \tool has flagged 344 cases where type C vulnerability is present. 
%We summarize the results in table \ref{tab:static_analysis}. 

\begin{table}[]
\centering
\resizebox{1.0\linewidth}{!}{%
\begin{tabular}{l|c|c}
   Stat  & \#API calls   & \#Files      \\ \hline
1. Callbacks exposed          & 156 (15.3\%) & 57 (12.8\%) \\
2. \texttt{skb\_shared\_info} mapped   & 464 (45.5\%) & 232 (51.9\%) \\
3. Callbacks exposed Directly & 54            & 28           \\
4. Private data mapped        & 19            & 7            \\
5. Stack Mapped                &     3          &         3     \\
6. Type C vulnerability       & 344           & 227          \\
7. \texttt{build\_skb} used            & 46            & 40           \\ \hline
Total dma-map calls        & 1019          & 447       \\  
\end{tabular}
%
}
\vspace{1mm}
\caption{\tool result summary.}
\label{tab:static_analysis}
\end{table}

\subsection{Output}
For each dma-mapping call, \tool outputs the line numbers of relevant declarations, function calls, and assignments, allowing for a human expert to trace back and validate the vulnerability. We present an example output of a vulnerability found in the NVMe host driver in Fig. \ref{fig:tool_example}.

The output starts from the impact evaluation, and continues with pertinent code lines. Starred lines contain script analysis. In Fig. \ref{fig:tool_example}, line 7 tells us that a single callback pointer is mapped in the mapped \texttt{nvme\_fc\_fcp\_op} data structure (i.e., \texttt{fcp\_req.done}) and line 8 tells us that it is possible to spoof another 931 callback pointers by rewriting contained pointers to data structures that contain other callback pointers. On Line 6, \tool, after finding the variable declaration (i.e., line 5) and looking at the mapped pointer (i.e., \texttt{\&op->rsp\_iu} on line 4), concludes that the whole \texttt{struct nvme\_fc\_fcp\_op} is exposed to the device. Lines 3-1 repeat the same analysis process for the \texttt{dma\_map\_single} call that exposes the data structure to the device. 

%.1\textwidth,
\begin{figure*}[t]
\begin{adjustbox}{width=\linewidth}
\lstset{
    escapechar={|}, 
    keywords=[2]{Callbacks},
    keywordstyle=[2]\color{gray},
    basicstyle=\color{red},
    keywordstyle=\color{purple},
    commentstyle=\color{teal},
    %morecomment=[s][\color{teal}]{/**}{*/}
    stringstyle=\color{blue},
}
        \begin{lstlisting}[
        basicstyle = \small,
        %basicstyle=\ttfamily,
        columns = fixed,
        tabsize=4,
        %frame = l,
        xleftmargin=0in,
        language = C,
       % moredelim=**[is][\color{red}]{@}{@},
        ]
[8]/*** Spoofed Vulnerability:*/ |\color{red}931| Callbacks reachable via sturct nvme_fc_fcp_op : DMA_FROM_DEVICE
[7]/*** Direct Vulnerability: */ |\color{red}1 |  Callback exposed in    struct nvme_fc_fcp_op : DMA_FROM_DEVICE
[6]/*mapped type:*/ struct nvme_fc_fcp_op
[5]/*DECLARATION*/["__nvme_fc_init_request:1698"]:__nvme_fc_init_request(struct nvme_fc_ctrl *ctrl,
                                                                struct nvme_fc_queue *queue, 
                                                                struct nvme_fc_fcp_op *op, 
                                                                struct request *rq, u32 rqno) {
[4]/*CALL*/["__nvme_fc_init_request:1731"]: fc_dma_map_single(ctrl->lport->dev,
                                                        &op->rsp_iu, sizeof(op->rsp_iu),
                                                        DMA_FROM_DEVICE);
[3]/*mapped type:*/ void
[2]/*DECLARATION*/["fc_dma_map_single:935"]:fc_dma_map_single(struct device *dev, void *ptr, size_t size, 
                                                    enum dma_data_direction dir) {
[1]/*CALL*/["fc_dma_map_single:939"]: return dev ? dma_map_single(dev, ptr, size, dir) : (dma_addr_t)0L;

                \end{lstlisting}
\end{adjustbox}
        \caption{\tool output example. Showing one path in the nvme\_fc driver where a callback pointer was exposed with write access.}
        \label{fig:tool_example}

\end{figure*}
%[4]RECURSION:1:drivers/nvme/host/fc.c __nvme_fc_init_request 1731