\section{Detecting Sub-Page Vulnerabilities}
We \DIFdelbegin \DIFdel{next }\DIFdelend \DIFaddbegin \DIFadd{now }\DIFaddend present the tools we \DIFdelbegin \DIFdel{have }\DIFdelend developed to identify \DIFaddbegin \DIFadd{the }\DIFaddend \subpage vulnerabilities described in the previous section.

\begin{figure*}
\begin{adjustbox}{width=\linewidth}
\lstset{
    escapechar={|}, 
    keywords=[2]{Callbacks},
    keywordstyle=[2]\color{gray},
    basicstyle=\color{red},
    keywordstyle=\color{purple},
    commentstyle=\color{teal},
    %morecomment=[s][\color{teal}]{/**}{*/}
    stringstyle=\color{blue},
}
        \begin{lstlisting}[
        %basicstyle = \small,
        basicstyle=\ttfamily,
        columns = fixed,
        tabsize=4,
        %frame = l,
        xleftmargin=0in,
        language = C,
       % moredelim=**[is][\color{red}]{@}{@},
        ]
[8]/*** Spoofed Vulnerability:*/ |\color{red}931| Callbacks reachable via struct nvme_fc_fcp_op : DMA_FROM_DEVICE
[7]/*** Direct Vulnerability: */ |\color{red}1 |  Callback exposed in    struct nvme_fc_fcp_op : DMA_FROM_DEVICE
[6]/*mapped type:*/ struct nvme_fc_fcp_op
[5]/*DECLARATION*/["__nvme_fc_init_request:1698"]:__nvme_fc_init_request(struct nvme_fc_ctrl *ctrl,
                                                                struct nvme_fc_queue *queue, struct nvme_fc_fcp_op *op, ...)
[4]/*CALL*/["__nvme_fc_init_request:1731"]: fc_dma_map_single(ctrl->lport->dev, &op->rsp_iu, 
                                                        sizeof(op->rsp_iu), DMA_FROM_DEVICE);
[3]/*mapped type:*/ void
[2]/*DECLARATION*/["fc_dma_map_single:935"]:fc_dma_map_single(struct device *dev, void *ptr, ...) {
[1]/*CALL*/["fc_dma_map_single:939"]: return dev ? dma_map_single(dev, ptr, size, dir) : (dma_addr_t)0L;

                
\end{lstlisting}
\end{adjustbox}
        \caption{\tool output example \DIFdelbeginFL \DIFdelFL{. Showing }\DIFdelendFL \DIFaddbeginFL \DIFaddFL{showing }\DIFaddendFL a path in the nvme\_fc driver where a callback pointer is exposed with write access.}
        \label{fig:tool_example}

\end{figure*}
%[4]RECURSION:1:drivers/nvme/host/fc.c __nvme_fc_init_request 1731

\subsection{Sub-Page Analysis for DMA Exposure}\label{sec:static-analysis}

%\adam{modify the subsection's title accordingly}\SV{updated.. in 5.2 as well..}
We \DIFdelbegin \DIFdel{devise }\DIFdelend \DIFaddbegin \DIFadd{devised }\DIFaddend a static code analysis tool that performs Sub-Page Analysis for DMA Exposure (\tool). With well over \DIFdelbegin \DIFdel{a }\DIFdelend 1000 \texttt{dma\_map*} function calls (i.e., the set of functions implementing the DMA API) \DIFdelbegin \DIFdel{, }\DIFdelend in the Linux kernel, a manual process would be arduous. \tool performs the following operations to detect the different \subpage{} vulnerability types (\DIFdelbegin \DIFdel{Fig.}\DIFdelend \DIFaddbegin \DIFadd{Figure}\DIFaddend ~\ref{fig:colocation}) where a callback pointer may be exposed:
\begin{enumerate}
    \item Type A: Looks for \texttt{dma\_map*} functions and traces back the call stack to identify \DIFdelbegin \DIFdel{if }\DIFdelend \DIFaddbegin \DIFadd{whether }\DIFaddend the mapped buffer is embedded inside a data structure.
    \item Type B: Looks for kernel APIs that create a data structure inside a mapped buffer (e.g., \texttt{build\_skb}).
    \item Type C: Looks for functions that are used for fast allocation by slicing a contiguous memory buffer into segments (e.g., netdev\_alloc\_skb, napi\_alloc\_skb). These may result in multiple \iova mapping the same page. These functions utilize the \texttt{page\_frag} API, which we discuss in greater detail in \DIFdelbegin \DIFdel{Sec. \ref{sec:shinfo_exploit}}\DIFdelend \DIFaddbegin \DIFadd{Section \ref{sec:shinfo_exploit}. 
}\DIFaddend \end{enumerate}


%\sout{\tool looks for \texttt{dma\_map*} functions and traces back the call stack to identify if the mapped buffer is embedded inside a data structure (Fig.~\ref{fig:colocation} (a)). Additionally we look for potentially hazardous functions (e.g., \texttt{build\_skb}), that create a data structure inside a mapped buffer (Fig.~\ref{fig:colocation} (b))}.\adam{this ``hazardous function'' comes out of nowhere and wasn't discussed in the characterization, which makes the  characterization looks questionable}
%The risk is classified according to the access permission. \means{} is implied by a READ permission and \oportunity{} is implied by a WRITE/BIDIRECTIONAL permission. 
%\sout{The case of multiple \iova{} (Fig.~\ref{fig:colocation} (c)), is also flagged by \tool, which flags use of functions (e.g., netdev\_alloc\_skb, napi\_alloc\_skb) that may result in this type of vulnerability or any other function that uses the page frag api.}
%\adam{why do specific functions cause this vulnerability and not other DMA API calls? explain what these ``bad'' functions do}\SV{see new description...}

%Currently, human expert input is needed to determine which functions are truly \emph{hazardous}, as acquiring \motivation and \oportunity is not done automatically. 
%As a result, \tool determines type (a) vulnerabilities automatically and types (b) and (c) only with sufficient human expert input. \textcolor{olive}{As we demonstrate in Sec.~\ref{sec:shinfo}.}

%The output of the tool presents structured and filtered findings conductive for more in-depth human expert analysis to determine if a viable attack is feasible. 

%Type (d) vulnerability falls under the category of random access\textcolor{olive}{,and we discuss such vulnerabilities} \st{and discussed further} in  Sec.~\ref{sec:dma-kasan}.

\subsubsection{High-Level Design Overview}

\tool operates recursively starting from calls to \DIFaddbegin \DIFadd{the }\DIFaddend dma\_map* functions. From this initial set of calls, \tool identifies the mapped variables and backtracks their declarations and assignments\DIFdelbegin \DIFdel{to these variables}\DIFdelend . When a data structure is identified as exposed, \tool identifies \DIFaddbegin \DIFadd{the }\DIFaddend exposed callback pointers or mapped heap pointers. 



\tool is implemented in \DIFdelbegin \DIFdel{$\approx$}\DIFdelend \DIFaddbegin \DIFadd{approximately }\DIFaddend 2000 lines of Perl 5 code. It \DIFdelbegin \DIFdel{utilises }\DIFdelend \DIFaddbegin \DIFadd{uses }\DIFaddend \texttt{pahole}~\cite{dwarves} to explore the compiled binaries for the layout of the exposed data structures. Pahole is a tool that uses the DWARF~\cite{dwarf} standardized debugging data format to examine data structure layout. To navigate the kernel code\DIFaddbegin \DIFadd{, }\DIFaddend \tool \DIFdelbegin \DIFdel{utilises }\DIFdelend \DIFaddbegin \DIFadd{uses }\DIFaddend Cscope~\cite{cscope,cscope_92} which is an open source tool for browsing C source code.

\tool is applicable to any kernel code written in C. We intend to make the \tool publicly available for the benefit of the research community.

%\adam{general comment: this is really short and makes the tool look trivial. Even if it's indeed trivial, isn't there anything interesting to say about it?}\SV{changed the title to reflect that it is only a high level description and edited the text.}

%The algorithm performs the following:
%\begin{enumerate}
%    \item Identify the mapped variable.
%    \item Locate variable declaration
%        \begin{itemize}
%            \item Identify biggest enclosing data structure that is mapped.
%            \item If callbacks located stop.
%        \end{itemize}
%    \item Locate Relevant assignments. For each:
%        \begin{itemize}
%            \item In case variable is assigned from new var restart from 2. 
%            \item in case of allocation: stop.
%        \end{itemize}
%    \item If declaration is reached:
%        \begin{itemize}
%            \item If function Call: Locate all calls and return to 1.
%            \item If on heap - check if heap is mapped: stop.
%        \end{itemize}
%\end{enumerate}

\subsubsection{Output}
%
%\adam{shouldn't this section come after the Design section, before discussing the results?}\SV{Done}
For each DMA-mapping call, \tool outputs the line numbers of relevant declarations, function calls, and assignments, allowing \DIFdelbegin \DIFdel{for a human expert }\DIFdelend \DIFaddbegin \DIFadd{human experts }\DIFaddend to trace back and validate the vulnerability. \DIFdelbegin \DIFdel{We present an example output of }\DIFdelend \DIFaddbegin \DIFadd{Figure~\ref{fig:tool_example} presents an example of output for }\DIFaddend a vulnerability found in the NVMe host driver\DIFdelbegin \DIFdel{in Fig.
~\ref{fig:tool_example}.
}\DIFdelend \DIFaddbegin \DIFadd{.
}\DIFaddend 

The output starts from the impact evaluation\DIFdelbegin \DIFdel{(e.g.,  }\DIFdelend \DIFaddbegin \DIFadd{,  such as }\DIFaddend detected exposed callback pointers\DIFdelbegin \DIFdel{) }\DIFdelend \DIFaddbegin \DIFadd{, }\DIFaddend and continues with pertinent code lines. %\sout{Starred lines contain script analysis}.
%\adam{what is script analysis? Who said anything about a script?}. 
Line 7 reveals \DIFdelbegin \DIFdel{us }\DIFdelend that a single callback pointer is mapped in the mapped \texttt{nvme\_fc\_fcp\_op} data structure (i.e., \texttt{fcp\_req.done}) and line 8 reveals that it is possible to spoof another 931 callback pointers.\footnote{In this case, spoofing means replacing this pointer to indicate an instance of the structure created by the device, with its own callback pointers.}
\DIFdelbegin \DIFdel{In Line 6, }%DIFDELCMD < \tool%%%
\DIFdel{, after }\DIFdelend \DIFaddbegin \DIFadd{After }\DIFaddend finding the variable declaration \DIFdelbegin \DIFdel{(i.e., }\DIFdelend \DIFaddbegin \DIFadd{in }\DIFaddend line 5\DIFdelbegin \DIFdel{) }\DIFdelend \DIFaddbegin \DIFadd{, }\DIFaddend and looking at the mapped pointer \DIFdelbegin \DIFdel{(i.e., }\DIFdelend \texttt{\&op->rsp\_iu} \DIFdelbegin \DIFdel{on }\DIFdelend \DIFaddbegin \DIFadd{in }\DIFaddend line 4\DIFdelbegin \DIFdel{), concludes that the whole }\DIFdelend \DIFaddbegin \DIFadd{, }\tool \DIFadd{concludes in line 6  that the entire }\DIFaddend \texttt{struct nvme\_fc\_fcp\_op} is exposed to the device. Lines \DIFdelbegin \DIFdel{3-1 }\DIFdelend \DIFaddbegin \DIFadd{1 through 3 }\DIFaddend repeat the same analysis process for the \texttt{dma\_map\_single} call that exposes the data structure to the device. 

This example demonstrates the recursive nature of the \DIFdelbegin \DIFdel{script}\DIFdelend \DIFaddbegin \DIFadd{analysis}\DIFaddend .
\tool first identifies the suspect function call, \DIFdelbegin \DIFdel{then }\DIFdelend finds the mapped pointer's declaration, and \DIFdelbegin \DIFdel{lastly }\DIFdelend \DIFaddbegin \DIFadd{then }\DIFaddend prints its type. This pattern repeats itself in lines \DIFdelbegin \DIFdel{1-3 and 4-6 }\DIFdelend \DIFaddbegin \DIFadd{1 through 3 and 4 through 6 }\DIFaddend until a vulnerability is discovered. The findings are then displayed\DIFdelbegin \DIFdel{; }\DIFdelend \DIFaddbegin \DIFadd{: }\DIFaddend line 7 counts the number of directly exposed callback pointers, and line 8 displays the number of callback pointers that may be potentially spoofed.



\subsubsection{Analysis and Results}
We \DIFdelbegin \DIFdel{use }\DIFdelend \DIFaddbegin \DIFadd{used }\DIFaddend \tool over Linux kernel 5.0 code,
\DIFdelbegin \DIFdel{analysing }\DIFdelend \DIFaddbegin \DIFadd{analyzing }\DIFaddend 1019 dma\_map\_single calls over 447 files. We present the results in \DIFdelbegin \DIFdel{Tab.}\DIFdelend \DIFaddbegin \DIFadd{Table}\DIFaddend ~\ref{tab:static_analysis}. 
We \DIFdelbegin \DIFdel{find }\DIFdelend \DIFaddbegin \DIFadd{found }\DIFaddend 156 cases in which device drivers expose callback pointers. Of these, 54 are cases \DIFdelbegin \DIFdel{where }\DIFdelend \DIFaddbegin \DIFadd{in which }\DIFaddend the pointers are exposed directly, and the rest are cases \DIFdelbegin \DIFdel{where }\DIFdelend \DIFaddbegin \DIFadd{in which }\DIFaddend callback pointers can be spoofed.
We \DIFdelbegin \DIFdel{find }\DIFdelend \DIFaddbegin \DIFadd{found }\DIFaddend that 13\%~(line 1 in Fig.~\ref{fig:tool_example}) of the drivers expose data structures via type (a) vulnerabilities\DIFaddbegin \DIFadd{, }\DIFaddend whereas 60\%~(lines 2,7 in Fig.~\ref{fig:tool_example}) expose data structures via type (b) vulnerabilities. Namely, 13\% are vulnerable due to driver bugs and 60\%~of drivers are vulnerable due to OS design choices. In the case of the Linux kernel, the most common source of vulnerability caused by the OS design is struct \shinfo, which is used ubiquitously in Linux networking. This data structure is \textit{always} located on the same page as the \texttt{skb->data}, and it also contains a callback pointer. We discuss the vulnerabilities related to \shinfo in \DIFdelbegin \DIFdel{Sec.}\DIFdelend \DIFaddbegin \DIFadd{Section}\DIFaddend ~\ref{sec:linux_net}. We \DIFdelbegin \DIFdel{find }\DIFdelend \DIFaddbegin \DIFadd{found }\DIFaddend that more than 50\% of the dma-map calls either directly map the \texttt{skb->data} or use the \texttt{build\_skb} API (lines 2 \DIFdelbegin \DIFdel{\& }\DIFdelend \DIFaddbegin \DIFadd{and }\DIFaddend 7 in Table ~\ref{tab:static_analysis}), which exposes \shinfo. The OS provides this data structure layout and API rather than it being an isolated driver bug. Additionally, we \DIFdelbegin \DIFdel{find }\DIFdelend \DIFaddbegin \DIFadd{found }\DIFaddend 19 data structures that are exposed via APIs that store \texttt{private} data structures on the same page as vulnerable \DIFdelbegin \DIFdel{meta-data}\DIFdelend \DIFaddbegin \DIFadd{metadata}\DIFaddend , e.g., netdev\_priv, aead\_request\_ctx\DIFaddbegin \DIFadd{, }\DIFaddend and scsi\_cmd\_priv.

In addition to type (a) and (b) vulnerabilities, \tool \DIFdelbegin \DIFdel{has additionally }\DIFdelend \DIFaddbegin \DIFadd{also }\DIFaddend flagged 344 cases where a type (c) vulnerability is present. Our analysis \DIFdelbegin \DIFdel{also finds }\DIFdelend \DIFaddbegin \DIFadd{found }\DIFaddend three instances where the stack pointer is mapped, potentially simplifying the execution of a ROP attack.

In total, we \DIFdelbegin \DIFdel{find }\DIFdelend \DIFaddbegin \DIFadd{found }\DIFaddend 742 dma-map calls (i.e., 72.8\% of all dma-map calls) with a potential vulnerability, of which 344 also admit a type (c) vulnerability.

Our code for \tool is publicly available \cite{SPADE}.


%\adam{flip the order of this paragraph. Start with the general findings (from the previous sentence and until the end of the paragraph, and then talk about shinfo, making it look like you discovered it by analyzing the tool's output. The current layout looks weird.} \SV{Done}


%(i.e., a pointer to a data structure which contains callbacks is exposed).
%\adam{unclear what pointer spoofing means, and why having a pointer to a data structure with a callback is useful. Is the ? Need to say this explicitly}
%\adam{the table says ``heap mapped'', not stack}.

%We summarize the results in table~\ref{tab:static_analysis}. 


\begin{table}[t]
\centering
\DIFdelbeginFL %DIFDELCMD < \resizebox{1.0\linewidth}{!}{%
%DIFDELCMD < \begin{tabular}{l|c|c}
%DIFDELCMD <    Stat  & \#API calls   & \#Files      \\ \hline
%DIFDELCMD < 1. Callbacks exposed          & 156 (15.3\%) & 57 (12.8\%) \\
%DIFDELCMD < 2. \texttt{skb\_shared\_info} mapped   & 464 (45.5\%) & 232 (51.9\%) \\
%DIFDELCMD < 3. Callbacks exposed Directly & 54            & 28           \\
%DIFDELCMD < 4. Private data mapped        & 19            & 7            \\
%DIFDELCMD < 5. Stack Mapped                &     3          &         3     \\
%DIFDELCMD < 6. Type C vulnerability       & 344           & 227          \\
%DIFDELCMD < 7. \texttt{build\_skb} used            & 46            & 40           \\ \hline
%DIFDELCMD < Total dma-map calls        & 1019          & 447       \\  
%DIFDELCMD < \end{tabular}
%DIFDELCMD < %
%DIFDELCMD < }
%DIFDELCMD < %%%
\DIFdelendFL \DIFaddbeginFL \resizebox{1.0\linewidth}{!}{%
\begin{tabular}{l|c|c}
   Stat  & \#API calls   & \#Files      \\ \hline
1. Callbacks exposed          & 156 (15.3\%) & 57 (12.8\%) \\
2. \texttt{skb\_shared\_info} mapped   & 464 (45.5\%) & 232 (51.9\%) \\
3. Callbacks exposed directly & 54            & 28           \\
4. Private data mapped        & 19            & 7            \\
5. Stack mapped                &     3          &         3     \\
6. Type C vulnerability       & 344           & 227          \\
7. \texttt{build\_skb} used            & 46            & 40           \\ \hline
Total dma-map calls        & 1019          & 447       \\  
\end{tabular}
%
}
\DIFaddendFL \vspace{1mm}
\caption{\tool \DIFdelbeginFL \DIFdelFL{result }\DIFdelendFL \DIFaddbeginFL \DIFaddFL{results }\DIFaddendFL summary\DIFdelbeginFL \DIFdelFL{.}\DIFdelendFL }
\vspace{-7mm}
\label{tab:static_analysis}
\end{table}

%.1\textwidth,