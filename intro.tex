\section{Introduction}

Direct Memory Access (DMA) is a technology that allows input-output (I/O) devices to access memory without CPU involvement, improving system performance.
DMA capable devices include internal devices, such as GPUs, Network Interface Cards (NICs), storage devices (e.g., NVMe) and other peripheral devices, and external devices such as FireWire and Thunderbolt devices.\footnote{Currently, the Linux kernel (version 5.0) has as much as 700 such device drivers, where a third of those are network device drivers.} However, in its basic form, DMA makes the system vulnerable to DMA attacks. Namely, cases where malicious DMA-capable devices (e.g., compromised firmware \cite{Gal14,Ben17a}) access sensitive memory regions not intended for their use. 


Numerous DMA exploits are known \cite{Dor04,BDK10,thunder}, ranging from stealing and manipulating sensitive data to taking over the victim machine. Widespread attacks include: opening a locked computer \cite{MM, Fin14}; executing arbitrary code on the victim machine \cite{Fri16, Woj08, AD10,thunder}; stealing sensitive data items such as passwords \cite{SB12, LKV13, Cim16, BR12}; extracting a full memory dump of a victim machine \cite{MM, Vol, Fin14, GA10}. These threats are mitigated by the Inputâ€“Output Memory Management Unit (IOMMU). The IOMMU adds a layer of virtual memory to devices. The IOMMU brokers all I/O requests, translating their target I/O virtual addresses (IOVAs) to physical addresses. In the process, the IOMMU provides address space isolation, allowing devices access only to permitted pages, rendering all other memory inaccessible.

Unlike processes that operate in page granularity, however, I/O buffers can be significantly smaller than a page. I/O buffers and other kernel buffers can co-reside on the same physical pages, inadvertently exposing these kernel buffers to the device. For this reason, known as the \subpage{} vulnerability \cite{MMT16,thunder}, IOMMU fails to protect the kernel from unprivileged access. Consequently, sub-page vulnerability was used as a basis for several recent DMA exploits.

Unfortunately, there is no systematic study of sub-page vulnerabilities and how to exploit them.
Previously reported vulnerabilities have an ad-hoc nature~\cite{thunder,MMT16,Ben17b} rather than a structured top-down approach. 

% \textcolor{olive}{Marketos et al.~\cite{thunder} have found that many OSs have basic DMA vulnerabilities that may lead to dire results. For the Linux kernel, however, which utilizes best IOMMU practices, there are no known DMA attacks, though some \subpage{} vulnerabilities were shown~\cite{thunder,MMT16,MSMT18}.
% %
% This paper is focused on the Linux kernel and disproves the above belief, showing that it is the kernel design that often enables a DMA attack (see Sec. \ref{sec:other_os} for a discussion on other OSes).}

Accordingly, in this paper, we first identify and then categorize four types\adam{who says there are four? first time this comes up}\SV{better?} of \subpage{} vulnerability, providing insight into the structure of DMA vulnerabilities (Sec. \ref{sec:subpage}):
\begin{itemize}
    \item Exposed Driver metadata.
    \item Exposed OS metadata. 
    \item Mapped by multiple \iova.
    \item Randomly co-located.
\end{itemize}
Then, to exploit these vulnerabilities, we present a schema for identifying viable attack vectors by malicious DMA capable devices. 

Our focus is on \emph{code injection} attacks. Accordingly, we introduce a trifecta of vulnerability attributes, which is sufficient to execute them\adam{should say the scope is code execution earlier and explicitly}\SV{added here and in the last paragraph of the abstract} (Sec. \ref{sec:mmo}):

\begin{itemize}
    \item A kernel virtual address of a kernel buffer filled with malicious executable code, a \mabaf.
    \item Write access to a function callback pointer, located in an exposed data structure.\adam{say that it's inside a struct on the page?}\SV{Done}
    \item Existence of a time window such that modifying the callback pointer during that time window is followed by the CPU reading the pointer without altering its content. 
\end{itemize} 
\adam{it looks strange to have these bullets, but no listing of the 4 vuln types. The characterizations should be treated consistently}\SV{Done}

With the characterization of the different sub-page vulnerabilities and the vulnerability attributes, we build analysis tools that detect potentially hazardous sub-page vulnerabilities:

\begin{itemize}
    \item We build a static code analysis tool that performs a Sub-Page Analysis for DMA Exposure (\tool) \adam{can you give it a better name? not only is this REALLY generic, but also: \url{https://www.merriam-webster.com/dictionary/scat}}\SV{Done} that flags high-risk device drivers. That is, \tool identifies drivers that expose callback pointers.
We use \tool on Linux kernel 5.0 and find that as much as 73\% of device drivers are potentially vulnerable to code injection attacks (Sec.~\ref{sec:static-analysis}). 

    \item Sub-page vulnerabilities can also manifest dynamically at run-time, potentially exposing callback pointers and/or kernel addresses. 
Static analysis may not reveal such vulnerabilities, where a memory buffer is inadvertently exposed due to randomly sharing a page with an I/O buffer. Accordingly, we further develop a run-time analysis tool, termed DMA-Kernel-Address-SANitizer (\dkasan)\adam{say what the acronym stands for}\SV{done} that reports such vulnerabilities and exemplify its use. \dkasan reports on all cases (inadvertently or otherwise) where a kernel-buffer is exposed~(Sec. \ref{sec:dma-kasan}).
\end{itemize}

Using the tools output, we then continue to demonstrate attacks on the Linux kernel.

\adam{the following paragraphs don't flow well from the previous text}\SV{better?}
First, we make the observation that previously reported DMA attacks are \simple, i.e., attacks in which the vulnerability trifecta is trivially provided. Namely, a callback pointer and a kernel virtual address of a DMA accessible page are present in a single page and the timing is such that the modifications will not be overwritten by the CPU. Such cases often lead to localized fixes rather than a comprehensive solution \cite{thunder}.

Our focus is on more sophisticated attacks, i.e., situations where the vulnerability trifecta is initially incomplete (termed \compound attacks).
Analysis of such cases, as we find in this work, reveals a dangerous misconception. It is assumed, that buggy device drivers or poor but isolated design choices, are to blame for DMA vulnerabilities. 
We demonstrate that, it is often the kernel itself, that supplements the missing pieces, showing that this is a deep-rooted issue rather than a collection of disjoint incidents.
We identify multiple kernel design flaws that facilitate the acquisition of the vulnerability trifecta by a malicious device.
To summarize, our contributions are:
\begin{itemize}
    \item We provide a categorisation of the four \subpage{} vulnerability types.
    \item We introduce the vulnerability trifecta which is sufficient to layout code-injection attacks.
    \item We develop static code analysis tool (\tool). We use it to evaluate the Linux kernel device drivers and report our findings.
    \item We develop a run-time tool (\dkasan) to identify \subpage{} vulnerabilities, including random access.
    \item We demonstrate novel DMA attacks on the Linux kernel termed \compound{} attacks.
\end{itemize}

% The rest of the paper is organized as follows:
% in Sec. \ref{sec:background} we provide the necessary technical background. 
% In Sec. \ref{sec:dma-risks} we introduce new theoretical basis to reason about DMA vulnerabilities.
% Next, inspired by the new theoretical basis, in Sec. \ref{sec:static-analysis} and \ref{sec:dma-kasan} we describe and evaluate the tools we built to discover DMA vulnerabilities. 
% In Sec. \ref{sec:linux_net} we discuss novel \compound attacks where human expertise is needed to complete the necessary attack ingredients.


